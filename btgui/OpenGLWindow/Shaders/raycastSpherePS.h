//this file is autogenerated using stringify.bat (premake --stringify) in the build folder of this project
static const char* raycastSphereFragmentShader= \
"#version 330 core\n"
"uniform mat4 projectionMatrix;\n"
"uniform float sphereRadius;  	//Sphere size in world space\n"
"uniform vec4 sphereColor;\n"
"in vec3 eyeSpherePosition;     	//Position of sphere center in eye space\n"
"out vec4 fragColor;\n"
"void main()\n"
"{\n"
"	const float SCALING = 1.6;		//Make sure this matches SCALING in raycastSphereVS.glsl\n"
"	const float INV_SCALING_SQUARED = (1.0/SCALING) * (1.0/SCALING);	//If gl_PointSize is scaled by N, then this should be (1/N)^2\n"
"	\n"
"	vec3 pointOnSphere;\n"
"	vec3 normalAtPointOnSphere;\n"
"	\n"
"	//Perform ray-sphere intersection test\n"
"	{\n"
"		vec3 rayDirection = normalize( eyeSpherePosition + vec3(gl_PointCoord.xy*2.0 - 1.0, 0.0)*sphereRadius );\n"
"		vec3 sphereCenter = eyeSpherePosition;\n"
"		\n"
"		float b = -2.0 * dot(rayDirection, sphereCenter);\n"
"		float c = dot(sphereCenter, sphereCenter) - sphereRadius * sphereRadius * INV_SCALING_SQUARED;	//	determine cause of scaling\n"
"		\n"
"		float discriminant = b*b - 4.0 * c;\n"
"		if(discriminant < 0.0) discard;		//Negative discriminant == no intersection\n"
"		\n"
"		float discriminant_sqrt = sqrt(discriminant);\n"
"		float t1 = (-b + discriminant_sqrt) * 0.5;\n"
"		float t2 = (-b - discriminant_sqrt) * 0.5;\n"
"		\n"
"		pointOnSphere = rayDirection * min(t1, t2);\n"
"		normalAtPointOnSphere = normalize(pointOnSphere - eyeSpherePosition);\n"
"	}\n"
"	\n"
"	vec4 clipSpacePosition = projectionMatrix * vec4(pointOnSphere, 1.0);\n"
"	float depth = clipSpacePosition.z / clipSpacePosition.w;\n"
"	\n"
"	const vec3 LIGHT_DIRECTION = vec3(0.577, 0.577, 0.577);\n"
"	const float SHININESS = 40.0;\n"
"	\n"
"	float diffuse = max( 0.0, dot(normalAtPointOnSphere, LIGHT_DIRECTION) );\n"
"	\n"
"	vec3 v = normalize(-eyeSpherePosition);		//Normalized vector pointing at camera/eye\n"
"	vec3 h = normalize(LIGHT_DIRECTION + v);	//Normalized vector halfway between LIGHT_DIRECTION and v\n"
"	float specular = pow( max(0.0, dot(normalAtPointOnSphere, h)), SHININESS );\n"
"	\n"
"	vec3 color = sphereColor.xyz * diffuse + specular;\n"
"	fragColor = vec4(color, 1.0);\n"
"	\n"
"	//Convert depth from Normalized Device Coordinates(NDC) to Window/Screen coordinates\n"
"	gl_FragDepth = (gl_DepthRange.diff*depth + gl_DepthRange.near + gl_DepthRange.far) * 0.5;\n"
"}\n"
;
