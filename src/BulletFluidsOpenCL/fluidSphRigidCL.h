//this file is autogenerated using stringify.bat (premake --stringify) in the build folder of this project
static const char* fluidSphRigidCL= \
"\n"
"#ifdef cl_amd_printf\n"
"	#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#endif\n"
"\n"
"typedef float b3Scalar;\n"
"typedef float4 b3Vector3;\n"
"#define b3Max max\n"
"#define b3Min min\n"
"\n"
"\n"
"//Note that these are vector3 functions -- OpenCL functions are vector4 functions\n"
"inline b3Scalar b3Vector3_length2(b3Vector3 v) { return v.x*v.x + v.y*v.y + v.z*v.z; }\n"
"inline b3Scalar b3Vector3_dot(b3Vector3 a, b3Vector3 b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n"
"inline b3Vector3 b3Vector3_normalize(b3Vector3 v)\n"
"{\n"
"	b3Scalar length2 = b3Vector3_length2(v);\n"
"	if( length2 != (b3Scalar)0.0f ) v /= sqrt(length2);\n"
"	\n"
"	return v;\n"
"}\n"
"//Defined in b3FluidSortingGrid.h\n"
"#define INVALID_FIRST_INDEX -1\n"
"#define INVALID_LAST_INDEX -2\n"
"\n"
"\n"
"//Syncronize with 'struct b3FluidSphParametersGlobal' in b3FluidSphParameters.h\n"
"typedef struct\n"
"{\n"
"	b3Scalar m_timeStep;\n"
"	b3Scalar m_simulationScale;\n"
"	b3Scalar m_speedLimit;\n"
"	b3Scalar m_sphSmoothRadius;\n"
"	b3Scalar m_sphRadiusSquared;\n"
"	b3Scalar m_poly6KernCoeff;\n"
"	b3Scalar m_spikyKernGradCoeff;\n"
"	b3Scalar m_viscosityKernLapCoeff;\n"
"	b3Scalar m_initialSum;\n"
"} b3FluidSphParametersGlobal;\n"
"\n"
"//Syncronize with 'struct b3FluidSphParametersLocal' in b3FluidSphParameters.h\n"
"typedef struct\n"
"{\n"
"	b3Vector3 m_aabbBoundaryMin;\n"
"	b3Vector3 m_aabbBoundaryMax;\n"
"	int m_enableAabbBoundary;\n"
"	b3Vector3 m_gravity;\n"
"	b3Scalar m_viscosity;\n"
"	b3Scalar m_restDensity;\n"
"	b3Scalar m_sphParticleMass;\n"
"	b3Scalar m_stiffness;\n"
"	b3Scalar m_particleDist;\n"
"	b3Scalar m_particleRadius;\n"
"	b3Scalar m_particleMargin;\n"
"	b3Scalar m_particleMass;\n"
"	b3Scalar m_boundaryStiff;\n"
"	b3Scalar m_boundaryDamp;\n"
"	b3Scalar m_boundaryFriction;\n"
"	b3Scalar m_boundaryRestitution;\n"
"	b3Scalar m_boundaryErp;\n"
"} b3FluidSphParametersLocal;\n"
"\n"
"\n"
"//#define B3_ENABLE_FLUID_SORTING_GRID_LARGE_WORLD_SUPPORT	//Ensure that this is also #defined in b3FluidSortingGrid.h\n"
"#ifdef B3_ENABLE_FLUID_SORTING_GRID_LARGE_WORLD_SUPPORT	\n"
"	typedef unsigned long b3FluidGridUint64;\n"
"	typedef b3FluidGridUint64 b3FluidGridCombinedPos;	//Range must contain B3_FLUID_GRID_COORD_RANGE^3\n"
"	#define B3_FLUID_GRID_COORD_RANGE 2097152		//2^21\n"
"	\n"
"	inline void splitCombinedPosition(b3FluidGridUint64 resolutionX, b3FluidGridUint64 resolutionY, \n"
"										b3FluidGridUint64 value, int* out_x, int* out_y, int* out_z)\n"
"	{\n"
"		b3FluidGridUint64 cellsPerLine = resolutionX;\n"
"		b3FluidGridUint64 cellsPerPlane = resolutionX * resolutionY;\n"
"		\n"
"		b3FluidGridUint64 x = value % cellsPerLine;\n"
"		b3FluidGridUint64 z = value / cellsPerPlane;\n"
"		b3FluidGridUint64 y = (value - z*cellsPerPlane) / cellsPerLine;\n"
"		\n"
"		*out_x = (int)x;\n"
"		*out_z = (int)z;\n"
"		*out_y = (int)y;\n"
"	}\n"
"#else\n"
"	typedef unsigned int b3FluidGridCombinedPos;		//Range must contain B3_FLUID_GRID_COORD_RANGE^3\n"
"	#define B3_FLUID_GRID_COORD_RANGE 1024			//2^10	\n"
"	\n"
"	inline void splitCombinedPosition(int resolutionX, int resolutionY, int value, int* out_x, int* out_y, int* out_z)\n"
"	{\n"
"		int x = value % resolutionX;\n"
"		int z = value / (resolutionX*resolutionY);\n"
"		int y = (value - z*resolutionX*resolutionY) / resolutionX;\n"
"		\n"
"		*out_x = (int)x;\n"
"		*out_z = (int)z;\n"
"		*out_y = (int)y;\n"
"	}\n"
"#endif\n"
"\n"
"typedef int b3FluidGridCoordinate;\n"
"#define B3_FLUID_GRID_COORD_RANGE_HALVED B3_FLUID_GRID_COORD_RANGE/2\n"
"\n"
"\n"
"\n"
"typedef struct\n"
"{\n"
"	int m_firstIndex;\n"
"	int m_lastIndex;\n"
"	\n"
"} b3FluidGridIterator;\n"
"\n"
"\n"
"//Since the hash function used to determine the 'value' of particles is simply \n"
"//(x + y*CELLS_PER_ROW + z*CELLS_PER_PLANE), adjacent cells have a value \n"
"//that is 1 greater and lesser than the current cell. \n"
"//This makes it possible to query 3 cells simultaneously(as a 3 cell bar extended along the x-axis) \n"
"//by using a 'binary range search' in the range [current_cell_value-1, current_cell_value+1]. \n"
"//Furthermore, as the 3 particle index ranges returned are also adjacent, it is also possible to \n"
"//stitch them together to form a single index range.\n"
"#define b3FluidSortingGrid_NUM_FOUND_CELLS_GPU 9\n"
"\n"
"typedef struct\n"
"{\n"
"	b3FluidGridIterator m_iterators[b3FluidSortingGrid_NUM_FOUND_CELLS_GPU];\n"
"	\n"
"} b3FluidSortingGridFoundCellsGpu;		//b3FluidSortingGrid::FoundCellsGpu in b3FluidSortingGrid.h\n"
"\n"
"typedef struct \n"
"{\n"
"	b3FluidGridCombinedPos m_value;\n"
"	int m_index;\n"
"	\n"
"} b3FluidGridValueIndexPair;\n"
"\n"
"typedef struct\n"
"{\n"
"	b3FluidGridCoordinate x;		\n"
"	b3FluidGridCoordinate y;\n"
"	b3FluidGridCoordinate z;\n"
"	b3FluidGridCoordinate padding;\n"
"	\n"
"} b3FluidGridPosition;\n"
"\n"
"b3FluidGridPosition getDiscretePosition(b3Scalar cellSize, b3Vector3 position)	//b3FluidSortingGrid::getDiscretePosition()\n"
"{\n"
"	b3Vector3 discretePosition = position / cellSize;\n"
"	\n"
"	b3FluidGridPosition result;\n"
"	result.x = (b3FluidGridCoordinate)( (position.x >= 0.0f) ? discretePosition.x : floor(discretePosition.x) );\n"
"	result.y = (b3FluidGridCoordinate)( (position.y >= 0.0f) ? discretePosition.y : floor(discretePosition.y) );\n"
"	result.z = (b3FluidGridCoordinate)( (position.z >= 0.0f) ? discretePosition.z : floor(discretePosition.z) );\n"
"	\n"
"	return result;\n"
"}\n"
"b3FluidGridCombinedPos getCombinedPosition(b3FluidGridPosition quantizedPosition)	//b3FluidGridPosition::getCombinedPosition()\n"
"{\n"
"	b3FluidGridCoordinate signedX = quantizedPosition.x + B3_FLUID_GRID_COORD_RANGE_HALVED;\n"
"	b3FluidGridCoordinate signedY = quantizedPosition.y + B3_FLUID_GRID_COORD_RANGE_HALVED;\n"
"	b3FluidGridCoordinate signedZ = quantizedPosition.z + B3_FLUID_GRID_COORD_RANGE_HALVED;\n"
"	\n"
"	b3FluidGridCombinedPos unsignedX = (b3FluidGridCombinedPos)signedX;\n"
"	b3FluidGridCombinedPos unsignedY = (b3FluidGridCombinedPos)signedY * B3_FLUID_GRID_COORD_RANGE;\n"
"	b3FluidGridCombinedPos unsignedZ = (b3FluidGridCombinedPos)signedZ * B3_FLUID_GRID_COORD_RANGE * B3_FLUID_GRID_COORD_RANGE;\n"
"	\n"
"	return unsignedX + unsignedY + unsignedZ;\n"
"}\n"
"\n"
"inline int binarySearch(__global b3FluidGridCombinedPos *sortGridValues, int sortGridValuesSize, b3FluidGridCombinedPos value)\n"
"{\n"
"	//From b3AlignedObjectArray::findBinarySearch()\n"
"	//Assumes sortGridValues[] is sorted\n"
"	\n"
"	int first = 0;\n"
"	int last = sortGridValuesSize - 1;\n"
"	\n"
"	while(first <= last) \n"
"	{\n"
"		int mid = (first + last) / 2;\n"
"		if(value > sortGridValues[mid]) first = mid + 1;\n"
"		else if(value < sortGridValues[mid]) last = mid - 1;\n"
"		else return mid;\n"
"	}\n"
"\n"
"	return sortGridValuesSize;\n"
"}\n"
"\n"
"\n"
"#define B3_EPSILON FLT_EPSILON\n"
"\n"
"//Syncronize with defines b3FluidSphRigidInteractorCL.h\n"
"#define MAX_FLUID_RIGID_PAIRS 32\n"
"#define MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE 16\n"
"#define MAX_FLUID_CONTACTS_PER_DYNAMIC_RIGID 256\n"
"\n"
"///Contains the indicies of rigid bodies whose AABB intersects with that of a single fluid particle\n"
"typedef struct\n"
"{\n"
"	int m_numIndicies;\n"
"	int m_rigidIndicies[MAX_FLUID_RIGID_PAIRS];\n"
"	int m_rigidSubIndicies[MAX_FLUID_RIGID_PAIRS];	//Only used if the rigid has triangle mesh or compound shape\n"
"	\n"
"} FluidRigidPairs;\n"
"\n"
"typedef struct\n"
"{\n"
"	int m_numContacts;\n"
"	int m_rigidIndicies[MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE];\n"
"	b3Scalar m_distances[MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE];\n"
"	b3Vector3 m_pointsOnRigid[MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE];		//World space point\n"
"	b3Vector3 m_normalsOnRigid[MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE];		//World space normal\n"
"	\n"
"} FluidRigidContacts;\n"
"\n"
"\n"
"\n"
"///Contains indicies of fluid particles that are colliding with dynamic(invMass != 0.0) rigid bodies\n"
"///If the rigid body is static, m_numContacts should be 0; this struct is used to apply fluid-rigid impulses to the rigid bodies\n"
"typedef struct\n"
"{\n"
"	int m_numContacts;\n"
"	\n"
"	//Fluid particle indicies; actual contact data is stored in the FluidRigidContact struct(1 per particle)\n"
"	int m_fluidIndicies[MAX_FLUID_CONTACTS_PER_DYNAMIC_RIGID];\n"
"	int m_contactIndicies[MAX_FLUID_CONTACTS_PER_DYNAMIC_RIGID];		//range [0, MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE - 1]\n"
"	\n"
"} RigidFluidContacts;\n"
"\n"
"\n"
"// -----------------------------------------------------------------------------\n"
"// Bullet3\n"
"// -----------------------------------------------------------------------------\n"
"#define SHAPE_CONVEX_HULL 3\n"
"#define SHAPE_PLANE 4\n"
"#define SHAPE_CONCAVE_TRIMESH 5\n"
"#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\n"
"#define SHAPE_SPHERE 7\n"
"\n"
"#define mymake_float4 (float4)\n"
"\n"
"typedef unsigned int u32;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_row[3];\n"
"}Matrix3x3;\n"
"\n"
"__inline\n"
"float dot3F4(float4 a, float4 b);\n"
"\n"
"__inline\n"
"float4 mtMul1(Matrix3x3 a, float4 b)\n"
"{\n"
"	float4 ans;\n"
"	ans.x = dot3F4( a.m_row[0], b );\n"
"	ans.y = dot3F4( a.m_row[1], b );\n"
"	ans.z = dot3F4( a.m_row[2], b );\n"
"	ans.w = 0.f;\n"
"	return ans;\n"
"}\n"
"\n"
"__inline\n"
"float4 mtMul3(float4 a, Matrix3x3 b)\n"
"{\n"
"	float4 colx = mymake_float4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\n"
"	float4 coly = mymake_float4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\n"
"	float4 colz = mymake_float4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\n"
"\n"
"	float4 ans;\n"
"	ans.x = dot3F4( a, colx );\n"
"	ans.y = dot3F4( a, coly );\n"
"	ans.z = dot3F4( a, colz );\n"
"	return ans;\n"
"}\n"
"\n"
"\n"
"///keep this in sync with btCollidable.h\n"
"typedef struct\n"
"{\n"
"	int m_numChildShapes;\n"
"	float m_radius;\n"
"	int m_shapeType;\n"
"	int m_shapeIndex;\n"
"	\n"
"} btCollidableGpu;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4	m_childPosition;\n"
"	float4	m_childOrientation;\n"
"	int m_shapeIndex;\n"
"	int m_unused0;\n"
"	int m_unused1;\n"
"	int m_unused2;\n"
"} btGpuChildShape;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_pos;\n"
"	float4 m_quat;\n"
"	float4 m_linVel;\n"
"	float4 m_angVel;\n"
"\n"
"	u32 m_collidableIdx;\n"
"	float m_invMass;\n"
"	float m_restituitionCoeff;\n"
"	float m_frictionCoeff;\n"
"} BodyData;				//b3RigidBodyCL in C++ (Bullet3Collision/NarrowPhaseCollision/b3RigidBodyCL.h)\n"
"\n"
"typedef struct\n"
"{\n"
"	Matrix3x3 m_invInertia;\n"
"	Matrix3x3 m_initInvInertia;\n"
"} InertiaTensor;		//b3InertiaCL in C++ (Bullet3Collision/NarrowPhaseCollision/b3RigidBodyCL.h)\n"
"\n"
"typedef struct  \n"
"{\n"
"	float4		m_localCenter;\n"
"	float4		m_extents;\n"
"	float4		mC;\n"
"	float4		mE;\n"
"	\n"
"	float			m_radius;\n"
"	int	m_faceOffset;\n"
"	int m_numFaces;\n"
"	int	m_numVertices;\n"
"\n"
"	int m_vertexOffset;\n"
"	int	m_uniqueEdgesOffset;\n"
"	int	m_numUniqueEdges;\n"
"	int m_unused;\n"
"} ConvexPolyhedronCL;	//b3ConvexPolyhedronCL in C++ (Bullet3OpenCL/NarrowphaseCollision/b3ConvexPolyhedronCL.h)\n"
"\n"
"typedef struct \n"
"{\n"
"	union\n"
"	{\n"
"		float4	m_min;\n"
"		float   m_minElems[4];\n"
"		int			m_minIndices[4];\n"
"	};\n"
"	union\n"
"	{\n"
"		float4	m_max;\n"
"		float   m_maxElems[4];\n"
"		int			m_maxIndices[4];\n"
"	};\n"
"} btAabbCL;		//b3SapAabb in C++ (Bullet3OpenCL/BroadphaseCollision/b3SapAabb.h)\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_plane;\n"
"	int m_indexOffset;\n"
"	int m_numIndices;\n"
"} btGpuFace;\n"
"\n"
"#define make_float4 (float4)\n"
"\n"
"typedef float4 Quaternion;\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b);\n"
"\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec);\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q);\n"
"\n"
"__inline\n"
"float4 cross3(float4 a, float4 b)\n"
"{\n"
"	return cross(a,b);\n"
"}\n"
"\n"
"__inline\n"
"float dot3F4(float4 a, float4 b)\n"
"{\n"
"	float4 a1 = make_float4(a.xyz,0.f);\n"
"	float4 b1 = make_float4(b.xyz,0.f);\n"
"	return dot(a1, b1);\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b)\n"
"{\n"
"	Quaternion ans;\n"
"	ans = cross3( a, b );\n"
"	ans += a.w*b+b.w*a;\n"
"//	ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\n"
"	ans.w = a.w*b.w - dot3F4(a, b);\n"
"	return ans;\n"
"}\n"
"\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec)\n"
"{\n"
"	Quaternion qInv = qtInvert( q );\n"
"	float4 vcpy = vec;\n"
"	vcpy.w = 0.f;\n"
"	float4 out = qtMul(qtMul(q,vcpy),qInv);\n"
"	return out;\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q)\n"
"{\n"
"	return (Quaternion)(-q.xyz, q.w);\n"
"}\n"
"\n"
"__inline\n"
"float4 qtInvRotate(const Quaternion q, float4 vec)\n"
"{\n"
"	return qtRotate( qtInvert( q ), vec );\n"
"}\n"
"\n"
"__inline\n"
"float4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\n"
"{\n"
"	return qtRotate( *orientation, *p ) + (*translation);\n"
"}\n"
"\n"
"void	trInverse(float4 translationIn, Quaternion orientationIn,\n"
"		float4* translationOut, Quaternion* orientationOut)\n"
"{\n"
"	*orientationOut = qtInvert(orientationIn);\n"
"	*translationOut = qtRotate(*orientationOut, -translationIn);\n"
"}\n"
"\n"
"void	trMul(float4 translationA, Quaternion orientationA,\n"
"						float4 translationB, Quaternion orientationB,\n"
"		float4* translationOut, Quaternion* orientationOut)\n"
"{\n"
"	*orientationOut = qtMul(orientationA,orientationB);\n"
"	*translationOut = transform(&translationB,&translationA,&orientationA);\n"
"}\n"
"\n"
"float signedDistanceFromPointToPlane(float4 point, float4 planeEqn, float4* closestPointOnFace)\n"
"{\n"
"	float4 n = (float4)(planeEqn.x, planeEqn.y, planeEqn.z, 0);\n"
"	float dist = dot3F4(n, point) + planeEqn.w;\n"
"	*closestPointOnFace = point - dist * n;\n"
"	return dist;\n"
"}\n"
"\n"
"inline bool IsPointInPolygon(float4 p, \n"
"							const btGpuFace* face,\n"
"							__global const float4* baseVertex,\n"
"							__global const  int* convexIndices,\n"
"							float4* out)\n"
"{\n"
"    float4 a;\n"
"    float4 b;\n"
"    float4 ab;\n"
"    float4 ap;\n"
"    float4 v;\n"
"\n"
"	float4 plane = make_float4(face->m_plane.x,face->m_plane.y,face->m_plane.z,0.f);\n"
"	\n"
"	if (face->m_numIndices<2)\n"
"		return false;\n"
"\n"
"	\n"
"	float4 v0 = baseVertex[convexIndices[face->m_indexOffset + face->m_numIndices-1]];\n"
"	\n"
"	b = v0;\n"
"\n"
"    for(unsigned i=0; i != face->m_numIndices; ++i)\n"
"    {\n"
"		a = b;\n"
"		float4 vi = baseVertex[convexIndices[face->m_indexOffset + i]];\n"
"		b = vi;\n"
"        ab = b-a;\n"
"        ap = p-a;\n"
"        v = cross3(ab,plane);\n"
"\n"
"        if (dot(ap, v) > 0.f)\n"
"        {\n"
"            float ab_m2 = dot(ab, ab);\n"
"            float rt = ab_m2 != 0.f ? dot(ab, ap) / ab_m2 : 0.f;\n"
"            if (rt <= 0.f)\n"
"            {\n"
"                *out = a;\n"
"            }\n"
"            else if (rt >= 1.f) \n"
"            {\n"
"                *out = b;\n"
"            }\n"
"            else\n"
"            {\n"
"            	float s = 1.f - rt;\n"
"				out[0].x = s * a.x + rt * b.x;\n"
"				out[0].y = s * a.y + rt * b.y;\n"
"				out[0].z = s * a.z + rt * b.z;\n"
"            }\n"
"            return false;\n"
"        }\n"
"    }\n"
"    return true;\n"
"}\n"
"\n"
"//Modified computeContactSphereConvex() from primitiveContacts.cl\n"
"bool computeContactSphereConvex\n"
"(\n"
"	int collidableIndexB, \n"
"	__global const btCollidableGpu* collidables,\n"
"	__global const ConvexPolyhedronCL* convexShapes,\n"
"	__global const float4* convexVertices,\n"
"	__global const int* convexIndices,\n"
"	__global const btGpuFace* faces,\n"
"	float4 spherePos2,\n"
"	float radius,\n"
"	float4 pos,\n"
"	float4 quat,\n"
"\n"
"	float* out_distance,\n"
"	float4* out_normalOnRigidWorld,\n"
"	float4* out_pointOnRigidWorld\n"
")\n"
"{\n"
"	float4 invPos;\n"
"	float4 invOrn;\n"
"\n"
"	trInverse(pos,quat, &invPos,&invOrn);\n"
"\n"
"	float4 spherePos = transform(&spherePos2,&invPos,&invOrn);\n"
"\n"
"	int shapeIndex = collidables[collidableIndexB].m_shapeIndex;\n"
"	int numFaces = convexShapes[shapeIndex].m_numFaces;\n"
"	float4 closestPnt = (float4)(0, 0, 0, 0);\n"
"	float4 hitNormalWorld = (float4)(0, 0, 0, 0);\n"
"	float minDist = -1000000.f;\n"
"	bool bCollide = true;\n"
"\n"
"	for ( int f = 0; f < numFaces; f++ )\n"
"	{\n"
"		btGpuFace face = faces[convexShapes[shapeIndex].m_faceOffset+f];\n"
"\n"
"		// set up a plane equation \n"
"		float4 planeEqn;\n"
"		float4 n1 = face.m_plane;\n"
"		n1.w = 0.f;\n"
"		planeEqn = n1;\n"
"		planeEqn.w = face.m_plane.w;\n"
"		\n"
"	\n"
"		// compute a signed distance from the vertex in cloth to the face of rigidbody.\n"
"		float4 pntReturn;\n"
"		float dist = signedDistanceFromPointToPlane(spherePos, planeEqn, &pntReturn);\n"
"\n"
"		// If the distance is positive, the plane is a separating plane. \n"
"		if ( dist > radius )\n"
"		{\n"
"			bCollide = false;\n"
"			break;\n"
"		}\n"
"\n"
"\n"
"		if (dist>0)\n"
"		{\n"
"			//might hit an edge or vertex\n"
"			float4 out;\n"
"			float4 zeroPos = make_float4(0,0,0,0);\n"
"\n"
"			bool isInPoly = IsPointInPolygon(spherePos,\n"
"					&face,\n"
"					&convexVertices[convexShapes[shapeIndex].m_vertexOffset],\n"
"					convexIndices,\n"
"           &out);\n"
"			if (isInPoly)\n"
"			{\n"
"				if (dist>minDist)\n"
"				{\n"
"					minDist = dist;\n"
"					closestPnt = pntReturn;\n"
"					hitNormalWorld = planeEqn;\n"
"					\n"
"				}\n"
"			} else\n"
"			{\n"
"				float4 tmp = spherePos-out;\n"
"				float l2 = dot(tmp,tmp);\n"
"				if (l2<radius*radius)\n"
"				{\n"
"					dist  = sqrt(l2);\n"
"					if (dist>minDist)\n"
"					{\n"
"						minDist = dist;\n"
"						closestPnt = out;\n"
"						hitNormalWorld = tmp/dist;\n"
"						\n"
"					}\n"
"					\n"
"				} else\n"
"				{\n"
"					bCollide = false;\n"
"					break;\n"
"				}\n"
"			}\n"
"		} else\n"
"		{\n"
"			if ( dist > minDist )\n"
"			{\n"
"				minDist = dist;\n"
"				closestPnt = pntReturn;\n"
"				hitNormalWorld.xyz = planeEqn.xyz;\n"
"			}\n"
"		}\n"
"		\n"
"	}\n"
"\n"
"	\n"
"\n"
"	if (bCollide && minDist > -10000)\n"
"	{\n"
"		float4 normalOnSurfaceB1 = qtRotate(quat,-hitNormalWorld);\n"
"		float4 pOnB1 = transform(&closestPnt,&pos,&quat);\n"
"		\n"
"		float actualDepth = minDist-radius;\n"
"		if (actualDepth<=0.f)\n"
"		{\n"
"			*out_distance = actualDepth;\n"
"			*out_normalOnRigidWorld = normalOnSurfaceB1;\n"
"			*out_pointOnRigidWorld = pOnB1;\n"
"			return true;\n"
"		}\n"
"	}\n"
"	\n"
"	return false;\n"
"}\n"
"\n"
"bool pointInTriangle(const float4* vertices, const float4* normal, float4 *p )\n"
"{\n"
"\n"
"	const float4* p1 = &vertices[0];\n"
"	const float4* p2 = &vertices[1];\n"
"	const float4* p3 = &vertices[2];\n"
"\n"
"	float4 edge1;	edge1 = (*p2 - *p1);\n"
"	float4 edge2;	edge2 = ( *p3 - *p2 );\n"
"	float4 edge3;	edge3 = ( *p1 - *p3 );\n"
"\n"
"	\n"
"	float4 p1_to_p; p1_to_p = ( *p - *p1 );\n"
"	float4 p2_to_p; p2_to_p = ( *p - *p2 );\n"
"	float4 p3_to_p; p3_to_p = ( *p - *p3 );\n"
"\n"
"	float4 edge1_normal; edge1_normal = ( cross(edge1,*normal));\n"
"	float4 edge2_normal; edge2_normal = ( cross(edge2,*normal));\n"
"	float4 edge3_normal; edge3_normal = ( cross(edge3,*normal));\n"
"\n"
"	\n"
"	\n"
"	float r1, r2, r3;\n"
"	r1 = dot(edge1_normal,p1_to_p );\n"
"	r2 = dot(edge2_normal,p2_to_p );\n"
"	r3 = dot(edge3_normal,p3_to_p );\n"
"	\n"
"	if ( r1 > 0 && r2 > 0 && r3 > 0 )\n"
"		return true;\n"
"    if ( r1 <= 0 && r2 <= 0 && r3 <= 0 ) \n"
"		return true;\n"
"	return false;\n"
"\n"
"}\n"
"\n"
"\n"
"float segmentSqrDistance(float4 from, float4 to,float4 p, float4* nearest) \n"
"{\n"
"	float4 diff = p - from;\n"
"	float4 v = to - from;\n"
"	float t = dot(v,diff);\n"
"	\n"
"	if (t > 0) \n"
"	{\n"
"		float dotVV = dot(v,v);\n"
"		if (t < dotVV) \n"
"		{\n"
"			t /= dotVV;\n"
"			diff -= t*v;\n"
"		} else \n"
"		{\n"
"			t = 1;\n"
"			diff -= v;\n"
"		}\n"
"	} else\n"
"	{\n"
"		t = 0;\n"
"	}\n"
"	*nearest = from + t*v;\n"
"	return dot(diff,diff);	\n"
"}\n"
"\n"
"//Modified computeContactSphereTriangle() from primitiveContacts.cl\n"
"bool computeContactSphereTriangle(const float4* triangleVertices, \n"
"								float4 spherePos2, \n"
"								float radius, \n"
"								float4 rigidPos, \n"
"								float4 rigidOrn,\n"
"									\n"
"								float* out_distance,\n"
"								float4* out_normalOnRigidWorld,\n"
"								float4* out_pointOnRigidWorld)\n"
"{\n"
"\n"
"	float4 invPos;\n"
"	float4 invOrn;\n"
"\n"
"	trInverse(rigidPos,rigidOrn, &invPos,&invOrn);\n"
"	float4 spherePos = transform(&spherePos2,&invPos,&invOrn);\n"
"	float4 closestPnt = (float4)(0, 0, 0, 0);\n"
"	float4 hitNormalWorld = (float4)(0, 0, 0, 0);\n"
"	float minDist = -1000000.f;\n"
"	bool bCollide = true;\n"
"\n"
"	\n"
"	//////////////////////////////////////\n"
"\n"
"	float4 sphereCenter;\n"
"	sphereCenter = spherePos;\n"
"\n"
"	const float4* vertices = triangleVertices;\n"
"	float contactBreakingThreshold = 0.f;//todo?\n"
"	float radiusWithThreshold = radius + contactBreakingThreshold;\n"
"	float4 edge10;\n"
"	edge10 = vertices[1]-vertices[0];\n"
"	edge10.w = 0.f;//is this needed?\n"
"	float4 edge20;\n"
"	edge20 = vertices[2]-vertices[0];\n"
"	edge20.w = 0.f;//is this needed?\n"
"	float4 normal = cross3(edge10,edge20);\n"
"	normal = normalize(normal);\n"
"	float4 p1ToCenter;\n"
"	p1ToCenter = sphereCenter - vertices[0];\n"
"	\n"
"	float distanceFromPlane = dot(p1ToCenter,normal);\n"
"\n"
"	if (distanceFromPlane < 0.f)\n"
"	{\n"
"		//triangle facing the other way\n"
"		distanceFromPlane *= -1.f;\n"
"		normal *= -1.f;\n"
"	}\n"
"	hitNormalWorld = normal;\n"
"\n"
"	bool isInsideContactPlane = distanceFromPlane < radiusWithThreshold;\n"
"	\n"
"	// Check for contact / intersection\n"
"	bool hasContact = false;\n"
"	float4 contactPoint;\n"
"	if (isInsideContactPlane) \n"
"	{\n"
"	\n"
"		if (pointInTriangle(vertices,&normal, &sphereCenter)) \n"
"		{\n"
"			// Inside the contact wedge - touches a point on the shell plane\n"
"			hasContact = true;\n"
"			contactPoint = sphereCenter - normal*distanceFromPlane;\n"
"			\n"
"		} else {\n"
"			// Could be inside one of the contact capsules\n"
"			float contactCapsuleRadiusSqr = radiusWithThreshold*radiusWithThreshold;\n"
"			float4 nearestOnEdge;\n"
"			int numEdges = 3;\n"
"			for (int i = 0; i < numEdges; i++) \n"
"			{\n"
"				float4 pa =vertices[i];\n"
"				float4 pb = vertices[(i+1)%3];\n"
"\n"
"				float distanceSqr = segmentSqrDistance(pa,pb,sphereCenter, &nearestOnEdge);\n"
"				if (distanceSqr < contactCapsuleRadiusSqr) \n"
"				{\n"
"					// Yep, we're inside a capsule\n"
"					hasContact = true;\n"
"					contactPoint = nearestOnEdge;\n"
"					\n"
"				}\n"
"				\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"	if (hasContact) \n"
"	{\n"
"\n"
"		closestPnt = contactPoint;\n"
"		float4 contactToCenter = sphereCenter - contactPoint;\n"
"		minDist = length(contactToCenter);\n"
"		if (minDist>0.f)\n"
"		{\n"
"			hitNormalWorld = normalize(contactToCenter);//*(1./minDist);\n"
"		}\n"
"		bCollide  = true;\n"
"	}\n"
"\n"
"\n"
"	/////////////////////////////////////\n"
"\n"
"	if (bCollide && minDist > -10000)\n"
"	{\n"
"		\n"
"		float4 normalOnSurfaceB1 = qtRotate(rigidOrn,-hitNormalWorld);\n"
"		float4 pOnB1 = transform(&closestPnt,&rigidPos,&rigidOrn);\n"
"		float actualDepth = minDist-radius;\n"
"\n"
"		\n"
"		if (actualDepth<=0.f)\n"
"		{\n"
"			*out_distance = actualDepth;\n"
"			*out_normalOnRigidWorld = normalOnSurfaceB1;\n"
"			*out_pointOnRigidWorld = pOnB1;\n"
"		}\n"
"	}\n"
"\n"
"	return hasContact;\n"
"}\n"
"// -----------------------------------------------------------------------------\n"
"// Bullet3\n"
"// -----------------------------------------------------------------------------\n"
"\n"
"\n"
"// -----------------------------------------------------------------------------\n"
"// Bullet3 - bvhTraversal.cl\n"
"// -----------------------------------------------------------------------------\n"
"#define MAX_NUM_PARTS_IN_BITS 10\n"
"\n"
"///btQuantizedBvhNode is a compressed aabb node, 16 bytes.\n"
"///Node can be used for leafnode or internal node. Leafnodes can point to 32-bit triangle index (non-negative range).\n"
"typedef struct\n"
"{\n"
"	//12 bytes\n"
"	unsigned short int	m_quantizedAabbMin[3];\n"
"	unsigned short int	m_quantizedAabbMax[3];\n"
"	//4 bytes\n"
"	int	m_escapeIndexOrTriangleIndex;\n"
"} btQuantizedBvhNode;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4		m_aabbMin;\n"
"	float4		m_aabbMax;\n"
"	float4		m_quantization;\n"
"	int			m_numNodes;\n"
"	int			m_numSubTrees;\n"
"	int			m_nodeOffset;\n"
"	int			m_subTreeOffset;\n"
"\n"
"} b3BvhInfo;\n"
"\n"
"\n"
"int	getTriangleIndex(const btQuantizedBvhNode* rootNode)\n"
"{\n"
"	unsigned int x=0;\n"
"	unsigned int y = (~(x&0))<<(31-MAX_NUM_PARTS_IN_BITS);\n"
"	// Get only the lower bits where the triangle index is stored\n"
"	return (rootNode->m_escapeIndexOrTriangleIndex&~(y));\n"
"}\n"
"\n"
"int isLeaf(const btQuantizedBvhNode* rootNode)\n"
"{\n"
"	//skipindex is negative (internal node), triangleindex >=0 (leafnode)\n"
"	return (rootNode->m_escapeIndexOrTriangleIndex >= 0)? 1 : 0;\n"
"}\n"
"	\n"
"int getEscapeIndex(const btQuantizedBvhNode* rootNode)\n"
"{\n"
"	return -rootNode->m_escapeIndexOrTriangleIndex;\n"
"}\n"
"\n"
"typedef struct\n"
"{\n"
"	//12 bytes\n"
"	unsigned short int	m_quantizedAabbMin[3];\n"
"	unsigned short int	m_quantizedAabbMax[3];\n"
"	//4 bytes, points to the root of the subtree\n"
"	int			m_rootNodeIndex;\n"
"	//4 bytes\n"
"	int			m_subtreeSize;\n"
"	int			m_padding[3];\n"
"} btBvhSubtreeInfo;\n"
"\n"
"\n"
"int testQuantizedAabbAgainstQuantizedAabb(\n"
"								const unsigned short int* aabbMin1,\n"
"								const unsigned short int* aabbMax1,\n"
"								const unsigned short int* aabbMin2,\n"
"								const unsigned short int* aabbMax2)\n"
"{\n"
"	//int overlap = 1;\n"
"	if (aabbMin1[0] > aabbMax2[0])\n"
"		return 0;\n"
"	if (aabbMax1[0] < aabbMin2[0])\n"
"		return 0;\n"
"	if (aabbMin1[1] > aabbMax2[1])\n"
"		return 0;\n"
"	if (aabbMax1[1] < aabbMin2[1])\n"
"		return 0;\n"
"	if (aabbMin1[2] > aabbMax2[2])\n"
"		return 0;\n"
"	if (aabbMax1[2] < aabbMin2[2])\n"
"		return 0;\n"
"	return 1;\n"
"	//overlap = ((aabbMin1[0] > aabbMax2[0]) || (aabbMax1[0] < aabbMin2[0])) ? 0 : overlap;\n"
"	//overlap = ((aabbMin1[2] > aabbMax2[2]) || (aabbMax1[2] < aabbMin2[2])) ? 0 : overlap;\n"
"	//overlap = ((aabbMin1[1] > aabbMax2[1]) || (aabbMax1[1] < aabbMin2[1])) ? 0 : overlap;\n"
"	//return overlap;\n"
"}\n"
"\n"
"\n"
"void quantizeWithClamp(unsigned short* out, float4 point2,int isMax, float4 bvhAabbMin, float4 bvhAabbMax, float4 bvhQuantization)\n"
"{\n"
"	float4 clampedPoint = max(point2,bvhAabbMin);\n"
"	clampedPoint = min (clampedPoint, bvhAabbMax);\n"
"\n"
"	float4 v = (clampedPoint - bvhAabbMin) * bvhQuantization;\n"
"	if (isMax)\n"
"	{\n"
"		out[0] = (unsigned short) (((unsigned short)(v.x+1.f) | 1));\n"
"		out[1] = (unsigned short) (((unsigned short)(v.y+1.f) | 1));\n"
"		out[2] = (unsigned short) (((unsigned short)(v.z+1.f) | 1));\n"
"	} else\n"
"	{\n"
"		out[0] = (unsigned short) (((unsigned short)(v.x) & 0xfffe));\n"
"		out[1] = (unsigned short) (((unsigned short)(v.y) & 0xfffe));\n"
"		out[2] = (unsigned short) (((unsigned short)(v.z) & 0xfffe));\n"
"	}\n"
"\n"
"}\n"
"\n"
"//Modified bvhTraversalKernel() from bvhTraversal.cl\n"
"void getIntersectingBvhLeaves(__global const btCollidableGpu* collidables,\n"
"							__global const btBvhSubtreeInfo* subtreeHeadersRoot,\n"
"							__global const btQuantizedBvhNode* quantizedNodesRoot,\n"
"							__global const b3BvhInfo* bvhInfos,\n"
"						\n"
"							int rigidBodyIndex, \n"
"							int trimeshCollidableIndex,\n"
"							int particleIndex, \n"
"							b3Vector3 particleAabbMin, \n"
"							b3Vector3 particleAabbMax,\n"
"							\n"
"							__global FluidRigidPairs* out_pairs)\n"
"{\n"
"	btCollidableGpu trimeshCollidable = collidables[trimeshCollidableIndex];\n"
"	if(trimeshCollidable.m_shapeType != SHAPE_CONCAVE_TRIMESH) return;\n"
"\n"
"\n"
"	b3BvhInfo bvhInfo = bvhInfos[trimeshCollidable.m_numChildShapes];\n"
"\n"
"	float4 bvhAabbMin = bvhInfo.m_aabbMin;\n"
"	float4 bvhAabbMax = bvhInfo.m_aabbMax;\n"
"	float4 bvhQuantization = bvhInfo.m_quantization;\n"
"	int numSubtreeHeaders = bvhInfo.m_numSubTrees;\n"
"	__global const btBvhSubtreeInfo* subtreeHeaders = &subtreeHeadersRoot[bvhInfo.m_subTreeOffset];\n"
"	__global const btQuantizedBvhNode* quantizedNodes = &quantizedNodesRoot[bvhInfo.m_nodeOffset];\n"
"	\n"
"\n"
"	unsigned short int quantizedQueryAabbMin[3];\n"
"	unsigned short int quantizedQueryAabbMax[3];\n"
"	quantizeWithClamp(quantizedQueryAabbMin,particleAabbMin,false,bvhAabbMin, bvhAabbMax,bvhQuantization);\n"
"	quantizeWithClamp(quantizedQueryAabbMax,particleAabbMax,true ,bvhAabbMin, bvhAabbMax,bvhQuantization);\n"
"	\n"
"	for (int i=0;i<numSubtreeHeaders;i++)\n"
"	{\n"
"		btBvhSubtreeInfo subtree = subtreeHeaders[i];\n"
"				\n"
"		int overlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin,quantizedQueryAabbMax,subtree.m_quantizedAabbMin,subtree.m_quantizedAabbMax);\n"
"		if (overlap != 0)\n"
"		{\n"
"			int startNodeIndex = subtree.m_rootNodeIndex;\n"
"			int endNodeIndex = subtree.m_rootNodeIndex+subtree.m_subtreeSize;\n"
"			int curIndex = startNodeIndex;\n"
"			int escapeIndex;\n"
"			int isLeafNode;\n"
"			int aabbOverlap;\n"
"			while (curIndex < endNodeIndex)\n"
"			{\n"
"				btQuantizedBvhNode rootNode = quantizedNodes[curIndex];\n"
"				aabbOverlap = testQuantizedAabbAgainstQuantizedAabb(quantizedQueryAabbMin,quantizedQueryAabbMax,rootNode.m_quantizedAabbMin,rootNode.m_quantizedAabbMax);\n"
"				isLeafNode = isLeaf(&rootNode);\n"
"				if (aabbOverlap)\n"
"				{\n"
"					if (isLeafNode)\n"
"					{\n"
"						int triangleIndex = getTriangleIndex(&rootNode);\n"
"						\n"
"						int pairIndex = atomic_inc(&out_pairs[particleIndex].m_numIndicies);\n"
"						if(pairIndex < MAX_FLUID_RIGID_PAIRS) \n"
"						{\n"
"							out_pairs[particleIndex].m_rigidIndicies[pairIndex] = rigidBodyIndex;\n"
"							out_pairs[particleIndex].m_rigidSubIndicies[pairIndex] = triangleIndex;\n"
"						}\n"
"					} \n"
"					curIndex++;\n"
"				} else\n"
"				{\n"
"					if (isLeafNode)\n"
"					{\n"
"						curIndex++;\n"
"					} else\n"
"					{\n"
"						escapeIndex = getEscapeIndex(&rootNode);\n"
"						curIndex += escapeIndex;\n"
"					}\n"
"				}\n"
"			}\n"
"		}\n"
"	}\n"
"\n"
"}\n"
"// -----------------------------------------------------------------------------\n"
"// Bullet3 - bvhTraversal.cl\n"
"// -----------------------------------------------------------------------------\n"
"\n"
"bool computeContactSpherePlane(float4 spherePos, float sphereRadius,\n"
"								float4 rigidPos, float4 rigidOrn, float4 rigidPlaneEquation,\n"
"								float* out_distance, float4* out_normalOnRigidWorld, float4* out_pointOnRigidWorld)\n"
"{\n"
"	//Convert sphere position from world space to rigid space\n"
"	float4 invRigidPos, invRigidOrn;\n"
"	trInverse(rigidPos, rigidOrn, &invRigidPos, &invRigidOrn);\n"
"\n"
"	float4 spherePosInRigidSpace = transform(&spherePos, &invRigidPos, &invRigidOrn);\n"
"	\n"
"	//\n"
"	float4 pointOnPlaneRigidSpace;\n"
"	float distance = signedDistanceFromPointToPlane(spherePosInRigidSpace, rigidPlaneEquation, &pointOnPlaneRigidSpace) - sphereRadius;\n"
"	\n"
"	if(distance < 0.f)\n"
"	{\n"
"		float4 normalOnPlaneRigidSpace = make_float4(rigidPlaneEquation.xyz, 0.f);\n"
"	\n"
"		//Convert contact from rigid space to world space\n"
"		*out_distance = distance;\n"
"		*out_normalOnRigidWorld = qtRotate(rigidOrn, normalOnPlaneRigidSpace); \n"
"		*out_pointOnRigidWorld = transform(&normalOnPlaneRigidSpace, &rigidPos, &rigidOrn);\n"
"		\n"
"		return true;\n"
"	}\n"
"	\n"
"	return false;\n"
"}\n"
"\n"
"bool computeContactSphereSphere(float4 particlePos, float particleRadius,\n"
"								float4 rigidPos, float rigidRadius,\n"
"								float* out_distance, float4* out_normalOnRigidWorld, float4* out_pointOnRigidWorld)\n"
"{\n"
"	float4 rigidToParticle = particlePos - rigidPos;\n"
"	float distanceBetweenCenters = length(rigidToParticle);\n"
"	float distance = distanceBetweenCenters - (particleRadius + rigidRadius);\n"
"	\n"
"	if(distance < 0.f)\n"
"	{\n"
"		*out_distance = distance;\n"
"		*out_normalOnRigidWorld = (distanceBetweenCenters > B3_EPSILON) ? rigidToParticle / distanceBetweenCenters : (float4)(0.f, 1.f, 0.f, 0.f);\n"
"		*out_pointOnRigidWorld = rigidPos + *out_normalOnRigidWorld*rigidRadius;\n"
"		\n"
"		return true;\n"
"	}\n"
"	\n"
"	return false;\n"
"}\n"
"\n"
"\n"
"__kernel void clearFluidRigidPairsAndContacts(__global FluidRigidPairs* pairs, __global FluidRigidPairs* midphasePairs,\n"
"											__global FluidRigidContacts* contacts, int numFluidParticles)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numFluidParticles) return;\n"
"	\n"
"	pairs[i].m_numIndicies = 0;\n"
"	midphasePairs[i].m_numIndicies = 0;\n"
"	contacts[i].m_numContacts = 0;\n"
"}\n"
"\n"
"__kernel void detectLargeAabbRigids(__constant b3FluidSphParametersGlobal* FG,  __constant b3FluidSphParametersLocal* FL,  \n"
"									__global btAabbCL* rigidBodyWorldAabbs,\n"
"									__global BodyData* rigidBodies, __global btCollidableGpu* collidables,\n"
"									__global int* out_numLargeAabbRigids, __global int* out_largeAabbRigidIndicies, \n"
"									int maxLargeRigidAabbs, int numRigidBodies)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numRigidBodies) return;\n"
"	\n"
"	b3Scalar gridCellSize = FG->m_sphSmoothRadius / FG->m_simulationScale;\n"
"	b3Scalar particleRadius = FL->m_particleRadius;\n"
"	b3Vector3 radiusAabbExtent = (b3Vector3){ particleRadius, particleRadius, particleRadius, 0.0f };\n"
"	\n"
"	btAabbCL rigidAabb = rigidBodyWorldAabbs[i];\n"
"	\n"
"	b3Vector3 expandedRigidAabbMin = rigidAabb.m_min - radiusAabbExtent;\n"
"	b3Vector3 expandedRigidAabbMax = rigidAabb.m_max + radiusAabbExtent;\n"
"	\n"
"	BodyData rigidBody = rigidBodies[i];\n"
"	int collidableIndex = rigidBody.m_collidableIdx;\n"
"	\n"
"	b3Scalar maxAabbExtent = gridCellSize * (b3Scalar)B3_FLUID_GRID_COORD_RANGE_HALVED;\n"
"	if( fabs(expandedRigidAabbMin.x) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMin.y) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMin.z) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.x) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.y) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.z) > maxAabbExtent\n"
"	 || collidables[collidableIndex].m_shapeType == SHAPE_CONCAVE_TRIMESH )\n"
"	{\n"
"		int largeRigidIndex = atomic_inc(out_numLargeAabbRigids);	//out_numLargeAabbRigids is assumed to be 0 before the kernel is executed\n"
"		if(largeRigidIndex < maxLargeRigidAabbs) out_largeAabbRigidIndicies[largeRigidIndex] = i;\n"
"	}\n"
"}\n"
"__kernel void fluidLargeRigidBroadphase(__constant b3FluidSphParametersGlobal* FG,  __constant b3FluidSphParametersLocal* FL, \n"
"										__global b3Vector3* fluidPosition, __global btAabbCL* rigidBodyWorldAabbs,\n"
"										__global BodyData* rigidBodies, __global btCollidableGpu* collidables,\n"
"										__global int* numLargeAabbRigids, __global int* largeAabbRigidIndicies,\n"
"										__global FluidRigidPairs* out_pairs, __global FluidRigidPairs* out_midphasePairs, \n"
"										int maxLargeRigidAabbs, int numFluidParticles)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numFluidParticles) return;\n"
"	\n"
"	b3Scalar gridCellSize = FG->m_sphSmoothRadius / FG->m_simulationScale;\n"
"	b3Scalar particleRadius = FL->m_particleRadius;\n"
"	b3Vector3 radiusAabbExtent = (b3Vector3){ particleRadius, particleRadius, particleRadius, 0.0f };\n"
"	\n"
"	b3Vector3 particlePos = fluidPosition[i];\n"
"	\n"
"	int numValidLargeAabbRigids = min(*numLargeAabbRigids, maxLargeRigidAabbs);\n"
"	for(int n = 0; n < numValidLargeAabbRigids; ++n)\n"
"	{\n"
"		int rigidIndex = largeAabbRigidIndicies[n];\n"
"	\n"
"		BodyData rigidBody = rigidBodies[rigidIndex];\n"
"		int collidableIndex = rigidBody.m_collidableIdx;\n"
"	\n"
"		bool needsMidphase = ( collidables[collidableIndex].m_shapeType == SHAPE_CONCAVE_TRIMESH \n"
"							|| collidables[collidableIndex].m_shapeType == SHAPE_COMPOUND_OF_CONVEX_HULLS );\n"
"						\n"
"		__global FluidRigidPairs* output = (needsMidphase) ? out_midphasePairs : out_pairs;\n"
"	\n"
"		btAabbCL rigidAabb = rigidBodyWorldAabbs[rigidIndex];\n"
"		b3Vector3 expandedRigidAabbMin = rigidAabb.m_min - radiusAabbExtent;\n"
"		b3Vector3 expandedRigidAabbMax = rigidAabb.m_max + radiusAabbExtent;\n"
"		\n"
"		if( expandedRigidAabbMin.x <= particlePos.x && particlePos.x <= expandedRigidAabbMax.x\n"
"		 && expandedRigidAabbMin.y <= particlePos.y && particlePos.y <= expandedRigidAabbMax.y\n"
"		 && expandedRigidAabbMin.z <= particlePos.z && particlePos.z <= expandedRigidAabbMax.z )\n"
"		{\n"
"			int pairIndex = output[i].m_numIndicies++;\n"
"			if(pairIndex < MAX_FLUID_RIGID_PAIRS) output[i].m_rigidIndicies[pairIndex] = rigidIndex;\n"
"			else return;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"__kernel void fluidSmallRigidBroadphase(__constant b3FluidSphParametersGlobal* FG,  __constant b3FluidSphParametersLocal* FL, \n"
"									__global b3Vector3* fluidPosition, __global b3FluidGridCombinedPos* cellValues, \n"
"									__global b3FluidGridIterator* cellContents, __global btAabbCL* rigidBodyWorldAabbs,\n"
"									__global BodyData* rigidBodies, __global btCollidableGpu* collidables,\n"
"									__global FluidRigidPairs* out_pairs, __global FluidRigidPairs* out_midphasePairs,			\n"
"									int numGridCells, int numRigidBodies)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numRigidBodies) return;\n"
"	\n"
"	b3Scalar gridCellSize = FG->m_sphSmoothRadius / FG->m_simulationScale;\n"
"	b3Scalar particleRadius = FL->m_particleRadius;\n"
"	b3Vector3 radiusAabbExtent = (b3Vector3){ particleRadius, particleRadius, particleRadius, 0.0f };\n"
"	\n"
"	btAabbCL rigidAabb = rigidBodyWorldAabbs[i];\n"
"	//rigidAabb.m_min.w = 0.0f;	//	check if necessary(if using vector functions for point-AABB test)\n"
"	//rigidAabb.m_max.w = 0.0f;\n"
"	\n"
"	b3Vector3 expandedRigidAabbMin = rigidAabb.m_min - radiusAabbExtent;\n"
"	b3Vector3 expandedRigidAabbMax = rigidAabb.m_max + radiusAabbExtent;\n"
"	\n"
"	BodyData rigidBody = rigidBodies[i];\n"
"	int collidableIndex = rigidBody.m_collidableIdx;\n"
"	\n"
"	bool needsMidphase = ( collidables[collidableIndex].m_shapeType == SHAPE_CONCAVE_TRIMESH \n"
"						|| collidables[collidableIndex].m_shapeType == SHAPE_COMPOUND_OF_CONVEX_HULLS );\n"
"						\n"
"	__global FluidRigidPairs* output = (needsMidphase) ? out_midphasePairs : out_pairs;\n"
"	\n"
"	b3Scalar maxAabbExtent = gridCellSize * (b3Scalar)B3_FLUID_GRID_COORD_RANGE_HALVED;\n"
"	if( fabs(expandedRigidAabbMin.x) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMin.y) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMin.z) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.x) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.y) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.z) > maxAabbExtent \n"
"	 || collidables[collidableIndex].m_shapeType == SHAPE_CONCAVE_TRIMESH ) return;\n"
"						\n"
"	b3FluidGridPosition quantizedAabbMin = getDiscretePosition( gridCellSize, expandedRigidAabbMin );\n"
"	b3FluidGridPosition quantizedAabbMax = getDiscretePosition( gridCellSize, expandedRigidAabbMax );\n"
"	\n"
"	for(int z = quantizedAabbMin.z; z <= quantizedAabbMax.z; ++z)\n"
"		for(int y = quantizedAabbMin.y; y <= quantizedAabbMax.y; ++y)\n"
"			for(int x = quantizedAabbMin.x; x <= quantizedAabbMax.x; ++x)\n"
"			{\n"
"				b3FluidGridPosition currentCell;\n"
"				currentCell.x = x;\n"
"				currentCell.y = y;\n"
"				currentCell.z = z;\n"
"				\n"
"				b3FluidGridCombinedPos currentCellValue = getCombinedPosition(currentCell);\n"
"			\n"
"				int cellIndex = binarySearch(cellValues, numGridCells, currentCellValue);\n"
"				if(cellIndex != numGridCells)\n"
"				{\n"
"					b3FluidGridIterator fluidCell = cellContents[cellIndex]; \n"
"					for(int particleIndex = fluidCell.m_firstIndex; particleIndex <= fluidCell.m_lastIndex; ++particleIndex)\n"
"					{\n"
"						b3Vector3 particlePos = fluidPosition[particleIndex];\n"
"						//particlePos.w = 0.0f;	//	check if necessary(if using vector functions for point-AABB test)\n"
"						\n"
"						if( expandedRigidAabbMin.x <= particlePos.x && particlePos.x <= expandedRigidAabbMax.x\n"
"						 && expandedRigidAabbMin.y <= particlePos.y && particlePos.y <= expandedRigidAabbMax.y\n"
"						 && expandedRigidAabbMin.z <= particlePos.z && particlePos.z <= expandedRigidAabbMax.z )\n"
"						{\n"
"							int pairIndex = atomic_inc(&output[particleIndex].m_numIndicies);\n"
"							if(pairIndex < MAX_FLUID_RIGID_PAIRS) output[particleIndex].m_rigidIndicies[pairIndex] = i;\n"
"						}\n"
"					}\n"
"				}\n"
"				\n"
"			}\n"
"	\n"
"}\n"
"\n"
"__kernel void fluidRigidMidphase(__constant b3FluidSphParametersLocal* FL, __global b3Vector3* fluidPosition, \n"
"								__global BodyData* rigidBodies, __global btCollidableGpu* collidables,\n"
"								__global b3BvhInfo* bvhInfos, __global btBvhSubtreeInfo* bvhSubtreeInfo, __global btQuantizedBvhNode* bvhNodes,\n"
"								__global FluidRigidPairs* midphasePairs, __global FluidRigidPairs* out_pairs, int numFluidParticles)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numFluidParticles) return;\n"
"	\n"
"	b3Scalar particleRadius = FL->m_particleRadius;\n"
"	b3Vector3 radiusAabbExtent = (b3Vector3){ particleRadius, particleRadius, particleRadius, 0.0f };\n"
"	\n"
"	b3Vector3 fluidAabbMin = fluidPosition[i] - radiusAabbExtent;\n"
"	b3Vector3 fluidAabbmax = fluidPosition[i] + radiusAabbExtent;\n"
"	\n"
"	//Convert each entry in midphasePairs into several entries in out_pairs\n"
"	int numIndicies = min(midphasePairs[i].m_numIndicies, MAX_FLUID_RIGID_PAIRS);\n"
"	for(int n = 0; n < numIndicies; ++n)\n"
"	{\n"
"		int rigidIndex = midphasePairs[i].m_rigidIndicies[n];\n"
"		BodyData rigidBody = rigidBodies[rigidIndex];\n"
"		int collidableIndex = rigidBody.m_collidableIdx;\n"
"		\n"
"		if(collidables[collidableIndex].m_shapeType == SHAPE_CONCAVE_TRIMESH)\n"
"		{\n"
"			//Traverse the triangle mesh BVH with particle AABB, adding 1 element to out_pairs\n"
"			//for each leaf(triangle) that intersects with the particle AABB\n"
"			 getIntersectingBvhLeaves(collidables, bvhSubtreeInfo, bvhNodes, bvhInfos, \n"
"										rigidIndex, collidableIndex,\n"
"										i, fluidAabbMin, fluidAabbmax, out_pairs);\n"
"		}\n"
"		else if(collidables[collidableIndex].m_shapeType == SHAPE_COMPOUND_OF_CONVEX_HULLS)\n"
"		{\n"
"			for(int childShape = 0; childShape < collidables[collidableIndex].m_numChildShapes; ++childShape)\n"
"			{\n"
"				int childShapeIndex = collidables[collidableIndex].m_shapeIndex + childShape;\n"
"				\n"
"				int pairIndex = atomic_inc(&out_pairs[i].m_numIndicies);\n"
"				if(pairIndex < MAX_FLUID_RIGID_PAIRS) \n"
"				{\n"
"					out_pairs[i].m_rigidIndicies[pairIndex] = rigidIndex;\n"
"					out_pairs[i].m_rigidSubIndicies[pairIndex] = childShapeIndex;\n"
"				}\n"
"			}\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"__kernel void fluidRigidNarrowphase(__constant b3FluidSphParametersGlobal* FG, __constant b3FluidSphParametersLocal* FL, \n"
"									__global b3Vector3* fluidPosition, __global FluidRigidPairs* pairs, \n"
"									__global BodyData* rigidBodies, __global btCollidableGpu* collidables,\n"
"									__global ConvexPolyhedronCL* convexShapes, __global btGpuFace* faces,\n"
"									__global int* convexIndices, __global float4* convexVertices, \n"
"									__global btGpuChildShape* gpuChildShapes, __global FluidRigidContacts* out_contact,\n"
"									int numFluidParticles)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numFluidParticles) return;\n"
"	\n"
"	FluidRigidPairs currentPairs = pairs[i];\n"
"	\n"
"	int numFluidRigidPairs = min(currentPairs.m_numIndicies, MAX_FLUID_RIGID_PAIRS);\n"
"	for(int pair = 0; pair < numFluidRigidPairs; ++pair)\n"
"	{\n"
"		int rigidIndex = currentPairs.m_rigidIndicies[pair];\n"
"	\n"
"		BodyData rigidBody = rigidBodies[rigidIndex];\n"
"		\n"
"		int collidableIndex = rigidBody.m_collidableIdx;\n"
"		\n"
"		bool isColliding = false;\n"
"		float distance;\n"
"		float4 normalOnRigid;\n"
"		float4 pointOnRigid;\n"
"		\n"
"		int shapeType = collidables[collidableIndex].m_shapeType;\n"
"		int shapeIndex = collidables[collidableIndex].m_shapeIndex;\n"
"		float4 rigidPosition = rigidBody.m_pos;\n"
"		float4 rigidOrientation = rigidBody.m_quat;\n"
"		\n"
"		if(shapeType == SHAPE_COMPOUND_OF_CONVEX_HULLS)\n"
"		{\n"
"			int childShapeIndex = currentPairs.m_rigidSubIndicies[pair];\n"
"			int childShapeCollidableIndex = gpuChildShapes[childShapeIndex].m_shapeIndex;\n"
"			float4 childWorldPosition = qtRotate(rigidOrientation, gpuChildShapes[childShapeIndex].m_childPosition) + rigidPosition;\n"
"			float4 childWorldOrientation = qtMul(rigidOrientation, gpuChildShapes[childShapeIndex].m_childOrientation);\n"
"			\n"
"			//Replace shape, position, orientation with that of the child shape\n"
"			shapeType = collidables[childShapeCollidableIndex].m_shapeType;\n"
"			shapeIndex = collidables[childShapeCollidableIndex].m_shapeIndex;\n"
"			rigidPosition = childWorldPosition;\n"
"			rigidOrientation = childWorldOrientation;\n"
"		}\n"
"		\n"
"		switch(shapeType)\n"
"		{\n"
"			case SHAPE_CONVEX_HULL:\n"
"			{\n"
"				isColliding = computeContactSphereConvex( collidableIndex, collidables, convexShapes, convexVertices, convexIndices, faces,\n"
"														fluidPosition[i], FL->m_particleRadius, rigidPosition, rigidOrientation,\n"
"														&distance, &normalOnRigid, &pointOnRigid );\n"
"				normalOnRigid = -normalOnRigid;		//	computeContactSphereConvex() actually returns normal on particle?\n"
"			}\n"
"				break;\n"
"				\n"
"			case SHAPE_PLANE:\n"
"			{\n"
"				float4 rigidPlaneEquation = faces[shapeIndex].m_plane;\n"
"		\n"
"				isColliding = computeContactSpherePlane(fluidPosition[i], FL->m_particleRadius, \n"
"														rigidPosition, rigidOrientation, rigidPlaneEquation,\n"
"														&distance, &normalOnRigid, &pointOnRigid );\n"
"			}\n"
"				break;\n"
"			\n"
"			case SHAPE_SPHERE:\n"
"			{\n"
"				float rigidSphereRadius = collidables[collidableIndex].m_radius;\n"
"			\n"
"				isColliding = computeContactSphereSphere(fluidPosition[i], FL->m_particleRadius,\n"
"														rigidPosition, rigidSphereRadius,\n"
"														&distance, &normalOnRigid, &pointOnRigid);\n"
"			}\n"
"				break;\n"
"				\n"
"			case SHAPE_CONCAVE_TRIMESH:\n"
"			{\n"
"				int rigidSubIndex = currentPairs.m_rigidSubIndicies[pair];\n"
"			\n"
"				float4 triangleVertices[3];\n"
"				\n"
"				btGpuFace face = faces[ convexShapes[shapeIndex].m_faceOffset + rigidSubIndex ];\n"
"		\n"
"				for (int j=0;j<3;j++)\n"
"				{\n"
"					int index = convexIndices[face.m_indexOffset + j];\n"
"					float4 vertex = convexVertices[ convexShapes[shapeIndex].m_vertexOffset + index];\n"
"					triangleVertices[j] = vertex;\n"
"				}\n"
"				\n"
"				isColliding = computeContactSphereTriangle(triangleVertices, fluidPosition[i], FL->m_particleRadius,\n"
"															rigidPosition, rigidOrientation,\n"
"															&distance, &normalOnRigid, &pointOnRigid);									\n"
"				normalOnRigid = -normalOnRigid;\n"
"			}\n"
"				break;\n"
"			\n"
"			default:\n"
"				continue;\n"
"		}\n"
"		\n"
"		\n"
"		if(isColliding)\n"
"		{\n"
"			int contactIndex = out_contact[i].m_numContacts;\n"
"			\n"
"			out_contact[i].m_rigidIndicies[contactIndex] = rigidIndex;\n"
"			out_contact[i].m_distances[contactIndex] = distance;\n"
"			out_contact[i].m_pointsOnRigid[contactIndex] = pointOnRigid;\n"
"			out_contact[i].m_normalsOnRigid[contactIndex] = normalOnRigid;		\n"
"			\n"
"			++out_contact[i].m_numContacts;\n"
"		}\n"
"		\n"
"		if(out_contact[i].m_numContacts >= MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE) return;\n"
"	}\n"
"}\n"
"\n"
"__kernel void resolveFluidRigidCollisions(__constant b3FluidSphParametersGlobal* FG, __constant b3FluidSphParametersLocal* FL, \n"
"											__global BodyData* rigidBodies, __global InertiaTensor* rigidInertias,\n"
"											__global FluidRigidContacts* contacts, \n"
"											__global b3Vector3* fluidVel, __global b3Vector3* fluidVelEval, int numFluidParticles)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numFluidParticles) return;\n"
"	\n"
"	for(int contactIndex = 0; contactIndex < contacts[i].m_numContacts; ++contactIndex)\n"
"	{\n"
"		b3Vector3 fluidVelocity = fluidVel[i];\n"
"		FluidRigidContacts contact = contacts[i];\n"
"	\n"
"		int rigidIndex = contact.m_rigidIndicies[contactIndex];\n"
"		b3Scalar distance = contact.m_distances[contactIndex];\n"
"		b3Vector3 normalOnRigid = contact.m_normalsOnRigid[contactIndex];\n"
"		b3Vector3 pointOnRigid = contact.m_pointsOnRigid[contactIndex];\n"
"		\n"
"		b3Vector3 rigidPosition = rigidBodies[rigidIndex].m_pos;\n"
"		b3Vector3 rigidLinearVelocity = rigidBodies[rigidIndex].m_linVel;\n"
"		b3Vector3 rigidAngularVelocity = rigidBodies[rigidIndex].m_angVel;\n"
"		b3Scalar rigidInvMass = rigidBodies[rigidIndex].m_invMass;\n"
"		Matrix3x3 rigidInertiaTensor = rigidInertias[rigidIndex].m_invInertia;\n"
"		\n"
"		if( distance < 0.0f )\n"
"		{\n"
"			bool isDynamicRigidBody = (rigidInvMass != 0.0f);\n"
"			\n"
"			b3Vector3 rigidLocalHitPoint = pointOnRigid - rigidPosition;\n"
"			\n"
"			b3Vector3 rigidVelocity = (b3Vector3){0.0f, 0.0f, 0.0f, 0.0f};\n"
"			if(isDynamicRigidBody) rigidVelocity = rigidLinearVelocity + cross3(rigidAngularVelocity, rigidLocalHitPoint);\n"
"			rigidVelocity *= FG->m_simulationScale;\n"
"		\n"
"			b3Vector3 relativeVelocity = fluidVelocity - rigidVelocity;\n"
"			b3Scalar penetratingMagnitude = b3Vector3_dot(relativeVelocity, -normalOnRigid);\n"
"			if( penetratingMagnitude < 0.0f ) penetratingMagnitude = 0.0f;\n"
"			\n"
"			b3Vector3 penetratingVelocity = -normalOnRigid * penetratingMagnitude;\n"
"			b3Vector3 tangentialVelocity = relativeVelocity - penetratingVelocity;\n"
"			\n"
"			penetratingVelocity *= 1.0f + FL->m_boundaryRestitution;\n"
"			\n"
"			b3Scalar penetration = -distance;\n"
"			penetration = (penetration > FL->m_particleMargin) ? penetration : 0.0f;\n"
"			b3Scalar positionError = penetration * (FG->m_simulationScale/FG->m_timeStep) * FL->m_boundaryErp;\n"
"			\n"
"			b3Vector3 particleImpulse = -(penetratingVelocity + (-normalOnRigid*positionError) + tangentialVelocity*FL->m_boundaryFriction);\n"
"			\n"
"			if(isDynamicRigidBody)\n"
"			{\n"
"				b3Scalar inertiaParticle = 1.0f / FL->m_particleMass;\n"
"				\n"
"				b3Vector3 relPosCrossNormal = cross3(rigidLocalHitPoint, normalOnRigid);\n"
"				b3Scalar inertiaRigid = rigidInvMass + b3Vector3_dot( mtMul3(relPosCrossNormal, rigidInertiaTensor), relPosCrossNormal );\n"
"				\n"
"				particleImpulse *= 1.0f / (inertiaParticle + inertiaRigid);\n"
"				\n"
"				//b3Vector3 worldScaleImpulse = -particleImpulse / FG->m_simulationScale;\n"
"				//worldScaleImpulse /= FG->m_timeStep;		//Impulse is accumulated as force\n"
"				\n"
"				//const b3Vector3& linearFactor = rigidBody->getLinearFactor();\n"
"				//accumulatedRigidForce += worldScaleImpulse * linearFactor;\n"
"				//accumulatedRigidTorque += rigidLocalHitPoint.cross(worldScaleImpulse * linearFactor) * rigidBody->getAngularFactor();\n"
"				\n"
"				particleImpulse *= inertiaParticle;\n"
"			}\n"
"			\n"
"			//Leapfrog integration\n"
"			b3Vector3 velNext = fluidVelocity + particleImpulse;\n"
"			fluidVelEval[i] = (fluidVelocity + velNext) * 0.5f;\n"
"			fluidVel[i] = velNext;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"\n"
"__kernel void clearRigidFluidContacts(__global RigidFluidContacts* out_rigidFluidContacts, int numRigidBodies)\n"
"{\n"
"	int rigidIndex = get_global_id(0);\n"
"	if(rigidIndex >= numRigidBodies) return;\n"
"	\n"
"	out_rigidFluidContacts[rigidIndex].m_numContacts = 0;\n"
"}\n"
"\n"
"__kernel void mapRigidFluidContacts(__global FluidRigidContacts* fluidRigidContacts,\n"
"									__global RigidFluidContacts* out_rigidFluidContacts, int numFluidParticles)\n"
"{\n"
"	int particleIndex = get_global_id(0);\n"
"	if(particleIndex >= numFluidParticles) return;\n"
"	\n"
"	FluidRigidContacts contacts = fluidRigidContacts[particleIndex];\n"
"	for(int n = 0; n < contacts.m_numContacts; ++n)\n"
"	{\n"
"		int rigidIndex = contacts.m_rigidIndicies[n];\n"
"		\n"
"		int pairIndex = atomic_inc(&out_rigidFluidContacts[rigidIndex].m_numContacts);\n"
"		if(pairIndex < MAX_FLUID_CONTACTS_PER_DYNAMIC_RIGID) \n"
"		{\n"
"			out_rigidFluidContacts[rigidIndex].m_fluidIndicies[pairIndex] = particleIndex;\n"
"			out_rigidFluidContacts[rigidIndex].m_contactIndicies[pairIndex] = n;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"__kernel void resolveRigidFluidCollisions(__constant b3FluidSphParametersGlobal* FG, __constant b3FluidSphParametersLocal* FL, \n"
"											__global BodyData* rigidBodies, __global InertiaTensor* rigidInertias,\n"
"											__global FluidRigidContacts* fluidContacts, __global RigidFluidContacts* rigidContacts, \n"
"											__global b3Vector3* fluidVel, int numRigidBodies)\n"
"{\n"
"	int rigidIndex = get_global_id(0);\n"
"	if(rigidIndex >= numRigidBodies) return;\n"
"	\n"
"	b3Vector3 rigidPosition = rigidBodies[rigidIndex].m_pos;\n"
"	b3Vector3 rigidLinearVelocity = rigidBodies[rigidIndex].m_linVel;\n"
"	b3Vector3 rigidAngularVelocity = rigidBodies[rigidIndex].m_angVel;\n"
"	b3Scalar rigidInvMass = rigidBodies[rigidIndex].m_invMass;\n"
"	Matrix3x3 rigidInertiaTensor = rigidInertias[rigidIndex].m_invInertia;\n"
"	\n"
"	if(rigidInvMass == 0.0f) return;\n"
"	\n"
"	b3Vector3 accumulatedForce = (b3Vector3){0.0f, 0.0f, 0.0f, 0.0f};\n"
"	b3Vector3 accumulatedTorque = (b3Vector3){0.0f, 0.0f, 0.0f, 0.0f};\n"
"	\n"
"	int numContacts = min(rigidContacts[rigidIndex].m_numContacts, MAX_FLUID_CONTACTS_PER_DYNAMIC_RIGID);\n"
"	for(int i = 0; i < numContacts; ++i)\n"
"	{\n"
"		int particleIndex = rigidContacts[rigidIndex].m_fluidIndicies[i];\n"
"		int contactIndex = rigidContacts[rigidIndex].m_contactIndicies[i];\n"
"		\n"
"		b3Vector3 fluidVelocity = fluidVel[particleIndex];\n"
"		\n"
"		b3Scalar distance = fluidContacts[particleIndex].m_distances[contactIndex];\n"
"		b3Vector3 pointOnRigid = fluidContacts[particleIndex].m_pointsOnRigid[contactIndex];\n"
"		b3Vector3 normalOnRigid = fluidContacts[particleIndex].m_normalsOnRigid[contactIndex];\n"
"		\n"
"		if( distance < 0.0f )\n"
"		{\n"
"			bool isDynamicRigidBody = (rigidInvMass != 0.0f);\n"
"			\n"
"			b3Vector3 rigidLocalHitPoint = pointOnRigid - rigidPosition;\n"
"			\n"
"			b3Vector3 rigidVelocity = (b3Vector3){0.0f, 0.0f, 0.0f, 0.0f};\n"
"			if(isDynamicRigidBody) rigidVelocity = rigidLinearVelocity + cross3(rigidAngularVelocity, rigidLocalHitPoint);\n"
"			rigidVelocity *= FG->m_simulationScale;\n"
"		\n"
"			b3Vector3 relativeVelocity = fluidVelocity - rigidVelocity;\n"
"			b3Scalar penetratingMagnitude = b3Vector3_dot(relativeVelocity, -normalOnRigid);\n"
"			if( penetratingMagnitude < 0.0f ) penetratingMagnitude = 0.0f;\n"
"			\n"
"			b3Vector3 penetratingVelocity = -normalOnRigid * penetratingMagnitude;\n"
"			b3Vector3 tangentialVelocity = relativeVelocity - penetratingVelocity;\n"
"			\n"
"			penetratingVelocity *= 1.0f + FL->m_boundaryRestitution;\n"
"			\n"
"			b3Scalar penetration = -distance;\n"
"			penetration = (penetration > FL->m_particleMargin) ? penetration : 0.0f;\n"
"			b3Scalar positionError = penetration * (FG->m_simulationScale/FG->m_timeStep) * FL->m_boundaryErp;\n"
"			\n"
"			b3Vector3 particleImpulse = -(penetratingVelocity + (-normalOnRigid*positionError) + tangentialVelocity*FL->m_boundaryFriction);\n"
"			\n"
"			if(isDynamicRigidBody)\n"
"			{\n"
"				b3Scalar inertiaParticle = 1.0f / FL->m_particleMass;\n"
"				\n"
"				b3Vector3 relPosCrossNormal = cross3(rigidLocalHitPoint, normalOnRigid);\n"
"				b3Scalar inertiaRigid = rigidInvMass + b3Vector3_dot( mtMul3(relPosCrossNormal, rigidInertiaTensor), relPosCrossNormal );\n"
"				\n"
"				particleImpulse *= 1.0f / (inertiaParticle + inertiaRigid);\n"
"				\n"
"				b3Vector3 worldScaleImpulse = -particleImpulse / FG->m_simulationScale;\n"
"				worldScaleImpulse /= FG->m_timeStep;		//Impulse is accumulated as force\n"
"				\n"
"				accumulatedForce += worldScaleImpulse;\n"
"				accumulatedTorque += cross3(rigidLocalHitPoint, worldScaleImpulse);\n"
"				\n"
"				//particleImpulse *= inertiaParticle;\n"
"			}\n"
"		}	\n"
"	}\n"
"	\n"
"	//Apply accumulated forces\n"
"	b3Scalar timeStep = FG->m_timeStep;\n"
"		\n"
"	rigidLinearVelocity += accumulatedForce * (rigidInvMass * timeStep);\n"
"	rigidAngularVelocity += mtMul1(rigidInertiaTensor, accumulatedTorque) * timeStep;\n"
"	\n"
"	//Limit angular velocity\n"
"	float BT_GPU_ANGULAR_MOTION_THRESHOLD = (0.25f * 3.14159254f);\n"
"	b3Scalar angVel = sqrt( b3Vector3_dot(rigidAngularVelocity, rigidAngularVelocity) );\n"
"	if(angVel*timeStep > BT_GPU_ANGULAR_MOTION_THRESHOLD) rigidAngularVelocity *= (BT_GPU_ANGULAR_MOTION_THRESHOLD/timeStep) / angVel;\n"
"	\n"
"	rigidBodies[rigidIndex].m_linVel = rigidLinearVelocity;\n"
"	rigidBodies[rigidIndex].m_angVel = rigidAngularVelocity;\n"
"}\n"
"\n"
;
