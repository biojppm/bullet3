//this file is autogenerated using stringify.bat (premake --stringify) in the build folder of this project
static const char* fluidSphRigidCL= \
"\n"
"#ifdef cl_amd_printf\n"
"	#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#endif\n"
"\n"
"typedef float b3Scalar;\n"
"typedef float4 b3Vector3;\n"
"#define b3Max max\n"
"#define b3Min min\n"
"\n"
"\n"
"//Note that these are vector3 functions -- OpenCL functions are vector4 functions\n"
"inline b3Scalar b3Vector3_length2(b3Vector3 v) { return v.x*v.x + v.y*v.y + v.z*v.z; }\n"
"inline b3Scalar b3Vector3_dot(b3Vector3 a, b3Vector3 b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n"
"inline b3Vector3 b3Vector3_normalize(b3Vector3 v)\n"
"{\n"
"	b3Scalar length2 = b3Vector3_length2(v);\n"
"	if( length2 != (b3Scalar)0.0f ) v /= sqrt(length2);\n"
"	\n"
"	return v;\n"
"}\n"
"//Defined in b3FluidSortingGrid.h\n"
"#define INVALID_FIRST_INDEX -1\n"
"#define INVALID_LAST_INDEX -2\n"
"\n"
"\n"
"//Syncronize with 'struct b3FluidSphParametersGlobal' in b3FluidSphParameters.h\n"
"typedef struct\n"
"{\n"
"	b3Scalar m_timeStep;\n"
"	b3Scalar m_simulationScale;\n"
"	b3Scalar m_speedLimit;\n"
"	b3Scalar m_sphSmoothRadius;\n"
"	b3Scalar m_sphRadiusSquared;\n"
"	b3Scalar m_poly6KernCoeff;\n"
"	b3Scalar m_spikyKernGradCoeff;\n"
"	b3Scalar m_viscosityKernLapCoeff;\n"
"	b3Scalar m_initialSum;\n"
"} b3FluidSphParametersGlobal;\n"
"\n"
"//Syncronize with 'struct b3FluidSphParametersLocal' in b3FluidSphParameters.h\n"
"typedef struct\n"
"{\n"
"	b3Vector3 m_aabbBoundaryMin;\n"
"	b3Vector3 m_aabbBoundaryMax;\n"
"	int m_enableAabbBoundary;\n"
"	b3Vector3 m_gravity;\n"
"	b3Scalar m_viscosity;\n"
"	b3Scalar m_restDensity;\n"
"	b3Scalar m_sphParticleMass;\n"
"	b3Scalar m_stiffness;\n"
"	b3Scalar m_particleDist;\n"
"	b3Scalar m_particleRadius;\n"
"	b3Scalar m_particleMargin;\n"
"	b3Scalar m_particleMass;\n"
"	b3Scalar m_boundaryStiff;\n"
"	b3Scalar m_boundaryDamp;\n"
"	b3Scalar m_boundaryFriction;\n"
"	b3Scalar m_boundaryRestitution;\n"
"	b3Scalar m_boundaryErp;\n"
"} b3FluidSphParametersLocal;\n"
"\n"
"\n"
"//#define B3_ENABLE_FLUID_SORTING_GRID_LARGE_WORLD_SUPPORT	//Ensure that this is also #defined in b3FluidSortingGrid.h\n"
"#ifdef B3_ENABLE_FLUID_SORTING_GRID_LARGE_WORLD_SUPPORT	\n"
"	typedef unsigned long b3FluidGridUint64;\n"
"	typedef b3FluidGridUint64 b3FluidGridCombinedPos;	//Range must contain B3_FLUID_GRID_COORD_RANGE^3\n"
"	#define B3_FLUID_GRID_COORD_RANGE 2097152		//2^21\n"
"	\n"
"	inline void splitCombinedPosition(b3FluidGridUint64 resolutionX, b3FluidGridUint64 resolutionY, \n"
"										b3FluidGridUint64 value, int* out_x, int* out_y, int* out_z)\n"
"	{\n"
"		b3FluidGridUint64 cellsPerLine = resolutionX;\n"
"		b3FluidGridUint64 cellsPerPlane = resolutionX * resolutionY;\n"
"		\n"
"		b3FluidGridUint64 x = value % cellsPerLine;\n"
"		b3FluidGridUint64 z = value / cellsPerPlane;\n"
"		b3FluidGridUint64 y = (value - z*cellsPerPlane) / cellsPerLine;\n"
"		\n"
"		*out_x = (int)x;\n"
"		*out_z = (int)z;\n"
"		*out_y = (int)y;\n"
"	}\n"
"#else\n"
"	typedef unsigned int b3FluidGridCombinedPos;		//Range must contain B3_FLUID_GRID_COORD_RANGE^3\n"
"	#define B3_FLUID_GRID_COORD_RANGE 1024			//2^10	\n"
"	\n"
"	inline void splitCombinedPosition(int resolutionX, int resolutionY, int value, int* out_x, int* out_y, int* out_z)\n"
"	{\n"
"		int x = value % resolutionX;\n"
"		int z = value / (resolutionX*resolutionY);\n"
"		int y = (value - z*resolutionX*resolutionY) / resolutionX;\n"
"		\n"
"		*out_x = (int)x;\n"
"		*out_z = (int)z;\n"
"		*out_y = (int)y;\n"
"	}\n"
"#endif\n"
"\n"
"typedef int b3FluidGridCoordinate;\n"
"#define B3_FLUID_GRID_COORD_RANGE_HALVED B3_FLUID_GRID_COORD_RANGE/2\n"
"\n"
"\n"
"\n"
"typedef struct\n"
"{\n"
"	int m_firstIndex;\n"
"	int m_lastIndex;\n"
"	\n"
"} b3FluidGridIterator;\n"
"\n"
"\n"
"//Since the hash function used to determine the 'value' of particles is simply \n"
"//(x + y*CELLS_PER_ROW + z*CELLS_PER_PLANE), adjacent cells have a value \n"
"//that is 1 greater and lesser than the current cell. \n"
"//This makes it possible to query 3 cells simultaneously(as a 3 cell bar extended along the x-axis) \n"
"//by using a 'binary range search' in the range [current_cell_value-1, current_cell_value+1]. \n"
"//Furthermore, as the 3 particle index ranges returned are also adjacent, it is also possible to \n"
"//stitch them together to form a single index range.\n"
"#define b3FluidSortingGrid_NUM_FOUND_CELLS_GPU 9\n"
"\n"
"typedef struct\n"
"{\n"
"	b3FluidGridIterator m_iterators[b3FluidSortingGrid_NUM_FOUND_CELLS_GPU];\n"
"	\n"
"} b3FluidSortingGridFoundCellsGpu;		//b3FluidSortingGrid::FoundCellsGpu in b3FluidSortingGrid.h\n"
"\n"
"typedef struct \n"
"{\n"
"	b3FluidGridCombinedPos m_value;\n"
"	int m_index;\n"
"	\n"
"} b3FluidGridValueIndexPair;\n"
"\n"
"typedef struct\n"
"{\n"
"	b3FluidGridCoordinate x;		\n"
"	b3FluidGridCoordinate y;\n"
"	b3FluidGridCoordinate z;\n"
"	b3FluidGridCoordinate padding;\n"
"	\n"
"} b3FluidGridPosition;\n"
"\n"
"b3FluidGridPosition getDiscretePosition(b3Scalar cellSize, b3Vector3 position)	//b3FluidSortingGrid::getDiscretePosition()\n"
"{\n"
"	b3Vector3 discretePosition = position / cellSize;\n"
"	\n"
"	b3FluidGridPosition result;\n"
"	result.x = (b3FluidGridCoordinate)( (position.x >= 0.0f) ? discretePosition.x : floor(discretePosition.x) );\n"
"	result.y = (b3FluidGridCoordinate)( (position.y >= 0.0f) ? discretePosition.y : floor(discretePosition.y) );\n"
"	result.z = (b3FluidGridCoordinate)( (position.z >= 0.0f) ? discretePosition.z : floor(discretePosition.z) );\n"
"	\n"
"	return result;\n"
"}\n"
"b3FluidGridCombinedPos getCombinedPosition(b3FluidGridPosition quantizedPosition)	//b3FluidGridPosition::getCombinedPosition()\n"
"{\n"
"	b3FluidGridCoordinate signedX = quantizedPosition.x + B3_FLUID_GRID_COORD_RANGE_HALVED;\n"
"	b3FluidGridCoordinate signedY = quantizedPosition.y + B3_FLUID_GRID_COORD_RANGE_HALVED;\n"
"	b3FluidGridCoordinate signedZ = quantizedPosition.z + B3_FLUID_GRID_COORD_RANGE_HALVED;\n"
"	\n"
"	b3FluidGridCombinedPos unsignedX = (b3FluidGridCombinedPos)signedX;\n"
"	b3FluidGridCombinedPos unsignedY = (b3FluidGridCombinedPos)signedY * B3_FLUID_GRID_COORD_RANGE;\n"
"	b3FluidGridCombinedPos unsignedZ = (b3FluidGridCombinedPos)signedZ * B3_FLUID_GRID_COORD_RANGE * B3_FLUID_GRID_COORD_RANGE;\n"
"	\n"
"	return unsignedX + unsignedY + unsignedZ;\n"
"}\n"
"\n"
"inline int binarySearch(__global b3FluidGridCombinedPos *sortGridValues, int sortGridValuesSize, b3FluidGridCombinedPos value)\n"
"{\n"
"	//From b3AlignedObjectArray::findBinarySearch()\n"
"	//Assumes sortGridValues[] is sorted\n"
"	\n"
"	int first = 0;\n"
"	int last = sortGridValuesSize - 1;\n"
"	\n"
"	while(first <= last) \n"
"	{\n"
"		int mid = (first + last) / 2;\n"
"		if(value > sortGridValues[mid]) first = mid + 1;\n"
"		else if(value < sortGridValues[mid]) last = mid - 1;\n"
"		else return mid;\n"
"	}\n"
"\n"
"	return sortGridValuesSize;\n"
"}\n"
"\n"
"// -----------------------------------------------------------------------------\n"
"// Bullet3\n"
"// -----------------------------------------------------------------------------\n"
"#define SHAPE_CONVEX_HULL 3\n"
"#define SHAPE_PLANE 4\n"
"#define SHAPE_CONCAVE_TRIMESH 5\n"
"#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\n"
"#define SHAPE_SPHERE 7\n"
"\n"
"#define mymake_float4 (float4)\n"
"\n"
"typedef unsigned int u32;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_row[3];\n"
"}Matrix3x3;\n"
"\n"
"__inline\n"
"float dot3F4(float4 a, float4 b);\n"
"\n"
"__inline\n"
"float4 mtMul1(Matrix3x3 a, float4 b)\n"
"{\n"
"	float4 ans;\n"
"	ans.x = dot3F4( a.m_row[0], b );\n"
"	ans.y = dot3F4( a.m_row[1], b );\n"
"	ans.z = dot3F4( a.m_row[2], b );\n"
"	ans.w = 0.f;\n"
"	return ans;\n"
"}\n"
"\n"
"__inline\n"
"float4 mtMul3(float4 a, Matrix3x3 b)\n"
"{\n"
"	float4 colx = mymake_float4(b.m_row[0].x, b.m_row[1].x, b.m_row[2].x, 0);\n"
"	float4 coly = mymake_float4(b.m_row[0].y, b.m_row[1].y, b.m_row[2].y, 0);\n"
"	float4 colz = mymake_float4(b.m_row[0].z, b.m_row[1].z, b.m_row[2].z, 0);\n"
"\n"
"	float4 ans;\n"
"	ans.x = dot3F4( a, colx );\n"
"	ans.y = dot3F4( a, coly );\n"
"	ans.z = dot3F4( a, colz );\n"
"	return ans;\n"
"}\n"
"\n"
"\n"
"///keep this in sync with btCollidable.h\n"
"typedef struct\n"
"{\n"
"	int m_numChildShapes;\n"
"	float m_radius;\n"
"	int m_shapeType;\n"
"	int m_shapeIndex;\n"
"	\n"
"} btCollidableGpu;\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_pos;\n"
"	float4 m_quat;\n"
"	float4 m_linVel;\n"
"	float4 m_angVel;\n"
"\n"
"	u32 m_collidableIdx;\n"
"	float m_invMass;\n"
"	float m_restituitionCoeff;\n"
"	float m_frictionCoeff;\n"
"} BodyData;				//b3RigidBodyCL in C++ (Bullet3Collision/NarrowPhaseCollision/b3RigidBodyCL.h)\n"
"\n"
"typedef struct\n"
"{\n"
"	Matrix3x3 m_invInertia;\n"
"	Matrix3x3 m_initInvInertia;\n"
"} InertiaTensor;		//b3InertiaCL in C++ (Bullet3Collision/NarrowPhaseCollision/b3RigidBodyCL.h)\n"
"\n"
"typedef struct  \n"
"{\n"
"	float4		m_localCenter;\n"
"	float4		m_extents;\n"
"	float4		mC;\n"
"	float4		mE;\n"
"	\n"
"	float			m_radius;\n"
"	int	m_faceOffset;\n"
"	int m_numFaces;\n"
"	int	m_numVertices;\n"
"\n"
"	int m_vertexOffset;\n"
"	int	m_uniqueEdgesOffset;\n"
"	int	m_numUniqueEdges;\n"
"	int m_unused;\n"
"} ConvexPolyhedronCL;	//b3ConvexPolyhedronCL in C++ (Bullet3OpenCL/NarrowphaseCollision/b3ConvexPolyhedronCL.h)\n"
"\n"
"typedef struct \n"
"{\n"
"	union\n"
"	{\n"
"		float4	m_min;\n"
"		float   m_minElems[4];\n"
"		int			m_minIndices[4];\n"
"	};\n"
"	union\n"
"	{\n"
"		float4	m_max;\n"
"		float   m_maxElems[4];\n"
"		int			m_maxIndices[4];\n"
"	};\n"
"} btAabbCL;		//b3SapAabb in C++ (Bullet3OpenCL/BroadphaseCollision/b3SapAabb.h)\n"
"\n"
"typedef struct\n"
"{\n"
"	float4 m_plane;\n"
"	int m_indexOffset;\n"
"	int m_numIndices;\n"
"} btGpuFace;\n"
"\n"
"#define make_float4 (float4)\n"
"\n"
"typedef float4 Quaternion;\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b);\n"
"\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec);\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q);\n"
"\n"
"__inline\n"
"float4 cross3(float4 a, float4 b)\n"
"{\n"
"	return cross(a,b);\n"
"}\n"
"\n"
"__inline\n"
"float dot3F4(float4 a, float4 b)\n"
"{\n"
"	float4 a1 = make_float4(a.xyz,0.f);\n"
"	float4 b1 = make_float4(b.xyz,0.f);\n"
"	return dot(a1, b1);\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtMul(Quaternion a, Quaternion b)\n"
"{\n"
"	Quaternion ans;\n"
"	ans = cross3( a, b );\n"
"	ans += a.w*b+b.w*a;\n"
"//	ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\n"
"	ans.w = a.w*b.w - dot3F4(a, b);\n"
"	return ans;\n"
"}\n"
"\n"
"__inline\n"
"float4 qtRotate(Quaternion q, float4 vec)\n"
"{\n"
"	Quaternion qInv = qtInvert( q );\n"
"	float4 vcpy = vec;\n"
"	vcpy.w = 0.f;\n"
"	float4 out = qtMul(qtMul(q,vcpy),qInv);\n"
"	return out;\n"
"}\n"
"\n"
"__inline\n"
"Quaternion qtInvert(Quaternion q)\n"
"{\n"
"	return (Quaternion)(-q.xyz, q.w);\n"
"}\n"
"\n"
"__inline\n"
"float4 qtInvRotate(const Quaternion q, float4 vec)\n"
"{\n"
"	return qtRotate( qtInvert( q ), vec );\n"
"}\n"
"\n"
"__inline\n"
"float4 transform(const float4* p, const float4* translation, const Quaternion* orientation)\n"
"{\n"
"	return qtRotate( *orientation, *p ) + (*translation);\n"
"}\n"
"\n"
"void	trInverse(float4 translationIn, Quaternion orientationIn,\n"
"		float4* translationOut, Quaternion* orientationOut)\n"
"{\n"
"	*orientationOut = qtInvert(orientationIn);\n"
"	*translationOut = qtRotate(*orientationOut, -translationIn);\n"
"}\n"
"\n"
"void	trMul(float4 translationA, Quaternion orientationA,\n"
"						float4 translationB, Quaternion orientationB,\n"
"		float4* translationOut, Quaternion* orientationOut)\n"
"{\n"
"	*orientationOut = qtMul(orientationA,orientationB);\n"
"	*translationOut = transform(&translationB,&translationA,&orientationA);\n"
"}\n"
"\n"
"float signedDistanceFromPointToPlane(float4 point, float4 planeEqn, float4* closestPointOnFace)\n"
"{\n"
"	float4 n = (float4)(planeEqn.x, planeEqn.y, planeEqn.z, 0);\n"
"	float dist = dot3F4(n, point) + planeEqn.w;\n"
"	*closestPointOnFace = point - dist * n;\n"
"	return dist;\n"
"}\n"
"\n"
"inline bool IsPointInPolygon(float4 p, \n"
"							const btGpuFace* face,\n"
"							__global const float4* baseVertex,\n"
"							__global const  int* convexIndices,\n"
"							float4* out)\n"
"{\n"
"    float4 a;\n"
"    float4 b;\n"
"    float4 ab;\n"
"    float4 ap;\n"
"    float4 v;\n"
"\n"
"	float4 plane = make_float4(face->m_plane.x,face->m_plane.y,face->m_plane.z,0.f);\n"
"	\n"
"	if (face->m_numIndices<2)\n"
"		return false;\n"
"\n"
"	\n"
"	float4 v0 = baseVertex[convexIndices[face->m_indexOffset + face->m_numIndices-1]];\n"
"	\n"
"	b = v0;\n"
"\n"
"    for(unsigned i=0; i != face->m_numIndices; ++i)\n"
"    {\n"
"		a = b;\n"
"		float4 vi = baseVertex[convexIndices[face->m_indexOffset + i]];\n"
"		b = vi;\n"
"        ab = b-a;\n"
"        ap = p-a;\n"
"        v = cross3(ab,plane);\n"
"\n"
"        if (dot(ap, v) > 0.f)\n"
"        {\n"
"            float ab_m2 = dot(ab, ab);\n"
"            float rt = ab_m2 != 0.f ? dot(ab, ap) / ab_m2 : 0.f;\n"
"            if (rt <= 0.f)\n"
"            {\n"
"                *out = a;\n"
"            }\n"
"            else if (rt >= 1.f) \n"
"            {\n"
"                *out = b;\n"
"            }\n"
"            else\n"
"            {\n"
"            	float s = 1.f - rt;\n"
"				out[0].x = s * a.x + rt * b.x;\n"
"				out[0].y = s * a.y + rt * b.y;\n"
"				out[0].z = s * a.z + rt * b.z;\n"
"            }\n"
"            return false;\n"
"        }\n"
"    }\n"
"    return true;\n"
"}\n"
"\n"
"//Modified computeContactSphereConvex() from primitiveContacts.cl\n"
"bool computeContactSphereConvex\n"
"(\n"
"	int collidableIndexB, \n"
"	__global const btCollidableGpu* collidables,\n"
"	__global const ConvexPolyhedronCL* convexShapes,\n"
"	__global const float4* convexVertices,\n"
"	__global const int* convexIndices,\n"
"	__global const btGpuFace* faces,\n"
"	float4 spherePos2,\n"
"	float radius,\n"
"	float4 pos,\n"
"	float4 quat,\n"
"\n"
"	float* out_distance,\n"
"	float4* out_normalOnRigidWorld,\n"
"	float4* out_pointOnRigidWorld\n"
")\n"
"{\n"
"	float4 invPos;\n"
"	float4 invOrn;\n"
"\n"
"	trInverse(pos,quat, &invPos,&invOrn);\n"
"\n"
"	float4 spherePos = transform(&spherePos2,&invPos,&invOrn);\n"
"\n"
"	int shapeIndex = collidables[collidableIndexB].m_shapeIndex;\n"
"	int numFaces = convexShapes[shapeIndex].m_numFaces;\n"
"	float4 closestPnt = (float4)(0, 0, 0, 0);\n"
"	float4 hitNormalWorld = (float4)(0, 0, 0, 0);\n"
"	float minDist = -1000000.f;\n"
"	bool bCollide = true;\n"
"\n"
"	for ( int f = 0; f < numFaces; f++ )\n"
"	{\n"
"		btGpuFace face = faces[convexShapes[shapeIndex].m_faceOffset+f];\n"
"\n"
"		// set up a plane equation \n"
"		float4 planeEqn;\n"
"		float4 n1 = face.m_plane;\n"
"		n1.w = 0.f;\n"
"		planeEqn = n1;\n"
"		planeEqn.w = face.m_plane.w;\n"
"		\n"
"	\n"
"		// compute a signed distance from the vertex in cloth to the face of rigidbody.\n"
"		float4 pntReturn;\n"
"		float dist = signedDistanceFromPointToPlane(spherePos, planeEqn, &pntReturn);\n"
"\n"
"		// If the distance is positive, the plane is a separating plane. \n"
"		if ( dist > radius )\n"
"		{\n"
"			bCollide = false;\n"
"			break;\n"
"		}\n"
"\n"
"\n"
"		if (dist>0)\n"
"		{\n"
"			//might hit an edge or vertex\n"
"			float4 out;\n"
"			float4 zeroPos = make_float4(0,0,0,0);\n"
"\n"
"			bool isInPoly = IsPointInPolygon(spherePos,\n"
"					&face,\n"
"					&convexVertices[convexShapes[shapeIndex].m_vertexOffset],\n"
"					convexIndices,\n"
"           &out);\n"
"			if (isInPoly)\n"
"			{\n"
"				if (dist>minDist)\n"
"				{\n"
"					minDist = dist;\n"
"					closestPnt = pntReturn;\n"
"					hitNormalWorld = planeEqn;\n"
"					\n"
"				}\n"
"			} else\n"
"			{\n"
"				float4 tmp = spherePos-out;\n"
"				float l2 = dot(tmp,tmp);\n"
"				if (l2<radius*radius)\n"
"				{\n"
"					dist  = sqrt(l2);\n"
"					if (dist>minDist)\n"
"					{\n"
"						minDist = dist;\n"
"						closestPnt = out;\n"
"						hitNormalWorld = tmp/dist;\n"
"						\n"
"					}\n"
"					\n"
"				} else\n"
"				{\n"
"					bCollide = false;\n"
"					break;\n"
"				}\n"
"			}\n"
"		} else\n"
"		{\n"
"			if ( dist > minDist )\n"
"			{\n"
"				minDist = dist;\n"
"				closestPnt = pntReturn;\n"
"				hitNormalWorld.xyz = planeEqn.xyz;\n"
"			}\n"
"		}\n"
"		\n"
"	}\n"
"\n"
"	\n"
"\n"
"	if (bCollide && minDist > -10000)\n"
"	{\n"
"		float4 normalOnSurfaceB1 = qtRotate(quat,-hitNormalWorld);\n"
"		float4 pOnB1 = transform(&closestPnt,&pos,&quat);\n"
"		\n"
"		float actualDepth = minDist-radius;\n"
"		if (actualDepth<=0.f)\n"
"		{\n"
"			*out_distance = actualDepth;\n"
"			*out_normalOnRigidWorld = normalOnSurfaceB1;\n"
"			*out_pointOnRigidWorld = pOnB1;\n"
"			return true;\n"
"		}\n"
"	}\n"
"	\n"
"	return false;\n"
"}\n"
"\n"
"\n"
"// -----------------------------------------------------------------------------\n"
"// Bullet3\n"
"// -----------------------------------------------------------------------------\n"
"\n"
"bool computeContactSpherePlane(float4 spherePos, float sphereRadius,\n"
"								float4 rigidPos, float4 rigidOrn, float4 rigidPlaneEquation,\n"
"								float* out_distance, float4* out_normalOnRigidWorld, float4* out_pointOnRigidWorld)\n"
"{\n"
"	//Convert sphere position from world space to rigid space\n"
"	float4 invRigidPos, invRigidOrn;\n"
"	trInverse(rigidPos, rigidOrn, &invRigidPos, &invRigidOrn);\n"
"\n"
"	float4 spherePosInRigidSpace = transform(&spherePos, &invRigidPos, &invRigidOrn);\n"
"	\n"
"	//\n"
"	float4 pointOnPlaneRigidSpace;\n"
"	float distance = signedDistanceFromPointToPlane(spherePosInRigidSpace, rigidPlaneEquation, &pointOnPlaneRigidSpace) - sphereRadius;\n"
"	\n"
"	if(distance < 0.f)\n"
"	{\n"
"		float4 normalOnPlaneRigidSpace = make_float4(rigidPlaneEquation.xyz, 0.f);\n"
"	\n"
"		//Convert contact from rigid space to world space\n"
"		*out_distance = distance;\n"
"		*out_normalOnRigidWorld = qtRotate(rigidOrn, normalOnPlaneRigidSpace); \n"
"		*out_pointOnRigidWorld = transform(&normalOnPlaneRigidSpace, &rigidPos, &rigidOrn);\n"
"		\n"
"		return true;\n"
"	}\n"
"	\n"
"	return false;\n"
"}\n"
"\n"
"#define B3_EPSILON FLT_EPSILON\n"
"bool computeContactSphereSphere(float4 particlePos, float particleRadius,\n"
"								float4 rigidPos, float rigidRadius,\n"
"								float* out_distance, float4* out_normalOnRigidWorld, float4* out_pointOnRigidWorld)\n"
"{\n"
"	float4 rigidToParticle = particlePos - rigidPos;\n"
"	float distanceBetweenCenters = length(rigidToParticle);\n"
"	float distance = distanceBetweenCenters - (particleRadius + rigidRadius);\n"
"	\n"
"	if(distance < 0.f)\n"
"	{\n"
"		*out_distance = distance;\n"
"		*out_normalOnRigidWorld = (distanceBetweenCenters > B3_EPSILON) ? rigidToParticle / distanceBetweenCenters : (float4)(0.f, 1.f, 0.f, 0.f);\n"
"		*out_pointOnRigidWorld = rigidPos + *out_normalOnRigidWorld*rigidRadius;\n"
"		\n"
"		return true;\n"
"	}\n"
"	\n"
"	return false;\n"
"}\n"
"\n"
"\n"
"#define MAX_FLUID_RIGID_PAIRS 32\n"
"#define MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE 4\n"
"#define MAX_FLUID_CONTACTS_PER_DYNAMIC_RIGID 256\n"
"\n"
"///Contains the indicies of rigid bodies whose AABB intersects with that of a single fluid particle\n"
"typedef struct\n"
"{\n"
"	int m_numIndicies;\n"
"	int m_rigidIndicies[MAX_FLUID_RIGID_PAIRS];\n"
"	\n"
"} FluidRigidPairs;\n"
"\n"
"typedef struct\n"
"{\n"
"	int m_numContacts;\n"
"	int m_rigidIndicies[MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE];\n"
"	b3Scalar m_distances[MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE];\n"
"	b3Vector3 m_pointsOnRigid[MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE];		//World space point\n"
"	b3Vector3 m_normalsOnRigid[MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE];		//World space normal\n"
"	\n"
"} FluidRigidContacts;\n"
"\n"
"\n"
"\n"
"///Contains indicies of fluid particles that are colliding with dynamic(invMass != 0.0) rigid bodies\n"
"///If the rigid body is static, m_numContacts should be 0; this struct is used to apply fluid-rigid impulses to the rigid bodies\n"
"typedef struct\n"
"{\n"
"	int m_numContacts;\n"
"	\n"
"	//Fluid particle indicies; actual contact data is stored in the FluidRigidContact struct(1 per particle)\n"
"	int m_fluidIndicies[MAX_FLUID_CONTACTS_PER_DYNAMIC_RIGID];\n"
"	int m_contactIndicies[MAX_FLUID_CONTACTS_PER_DYNAMIC_RIGID];		//range [0, MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE - 1]\n"
"	\n"
"} RigidFluidContacts;\n"
"\n"
"\n"
"__kernel void clearFluidRigidPairsAndContacts(__global FluidRigidPairs* pairs, __global FluidRigidContacts* contacts, int numFluidParticles)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numFluidParticles) return;\n"
"	\n"
"	pairs[i].m_numIndicies = 0;\n"
"	contacts[i].m_numContacts = 0;\n"
"}\n"
"\n"
"__kernel void detectLargeAabbRigids(__constant b3FluidSphParametersGlobal* FG,  __constant b3FluidSphParametersLocal* FL,  \n"
"									__global btAabbCL* rigidBodyWorldAabbs,\n"
"									__global int* out_numLargeAabbRigids, __global int* out_largeAabbRigidIndicies, \n"
"									int maxLargeRigidAabbs, int numRigidBodies)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numRigidBodies) return;\n"
"	\n"
"	b3Scalar gridCellSize = FG->m_sphSmoothRadius / FG->m_simulationScale;\n"
"	b3Scalar particleRadius = FL->m_particleRadius;\n"
"	b3Vector3 radiusAabbExtent = (b3Vector3){ particleRadius, particleRadius, particleRadius, 0.0f };\n"
"	\n"
"	btAabbCL rigidAabb = rigidBodyWorldAabbs[i];\n"
"	\n"
"	b3Vector3 expandedRigidAabbMin = rigidAabb.m_min - radiusAabbExtent;\n"
"	b3Vector3 expandedRigidAabbMax = rigidAabb.m_max + radiusAabbExtent;\n"
"	\n"
"	b3Scalar maxAabbExtent = gridCellSize * (b3Scalar)B3_FLUID_GRID_COORD_RANGE_HALVED;\n"
"	if( fabs(expandedRigidAabbMin.x) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMin.y) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMin.z) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.x) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.y) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.z) > maxAabbExtent )\n"
"	{\n"
"		int largeRigidIndex = atomic_inc(out_numLargeAabbRigids);	//out_numLargeAabbRigids is assumed to be 0 before the kernel is executed\n"
"		if(largeRigidIndex < maxLargeRigidAabbs) out_largeAabbRigidIndicies[largeRigidIndex] = i;\n"
"	}\n"
"}\n"
"__kernel void fluidLargeRigidBroadphase(__constant b3FluidSphParametersGlobal* FG,  __constant b3FluidSphParametersLocal* FL, \n"
"										__global b3Vector3* fluidPosition, __global btAabbCL* rigidBodyWorldAabbs,\n"
"										__global int* numLargeAabbRigids, __global int* largeAabbRigidIndicies,\n"
"										__global FluidRigidPairs* out_pairs, int numFluidParticles)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numFluidParticles) return;\n"
"	\n"
"	b3Scalar gridCellSize = FG->m_sphSmoothRadius / FG->m_simulationScale;\n"
"	b3Scalar particleRadius = FL->m_particleRadius;\n"
"	b3Vector3 radiusAabbExtent = (b3Vector3){ particleRadius, particleRadius, particleRadius, 0.0f };\n"
"	\n"
"	b3Vector3 particlePos = fluidPosition[i];\n"
"	\n"
"	for(int n = 0; n < *numLargeAabbRigids; ++n)\n"
"	{\n"
"		int rigidIndex = largeAabbRigidIndicies[n];\n"
"		\n"
"		btAabbCL rigidAabb = rigidBodyWorldAabbs[rigidIndex];\n"
"		b3Vector3 expandedRigidAabbMin = rigidAabb.m_min - radiusAabbExtent;\n"
"		b3Vector3 expandedRigidAabbMax = rigidAabb.m_max + radiusAabbExtent;\n"
"		\n"
"		if( expandedRigidAabbMin.x <= particlePos.x && particlePos.x <= expandedRigidAabbMax.x\n"
"		 && expandedRigidAabbMin.y <= particlePos.y && particlePos.y <= expandedRigidAabbMax.y\n"
"		 && expandedRigidAabbMin.z <= particlePos.z && particlePos.z <= expandedRigidAabbMax.z )\n"
"		{\n"
"			int pairIndex = out_pairs[i].m_numIndicies++;\n"
"			if(pairIndex < MAX_FLUID_RIGID_PAIRS) out_pairs[i].m_rigidIndicies[pairIndex] = rigidIndex;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"__kernel void fluidSmallRigidBroadphase(__constant b3FluidSphParametersGlobal* FG,  __constant b3FluidSphParametersLocal* FL, \n"
"									__global b3Vector3* fluidPosition, __global b3FluidGridCombinedPos* cellValues, \n"
"									__global b3FluidGridIterator* cellContents, __global btAabbCL* rigidBodyWorldAabbs,\n"
"									__global FluidRigidPairs* out_pairs, 			\n"
"									int numGridCells, int numRigidBodies)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	\n"
"	if(i >= numRigidBodies) return;\n"
"	\n"
"	b3Scalar gridCellSize = FG->m_sphSmoothRadius / FG->m_simulationScale;\n"
"	b3Scalar particleRadius = FL->m_particleRadius;\n"
"	b3Vector3 radiusAabbExtent = (b3Vector3){ particleRadius, particleRadius, particleRadius, 0.0f };\n"
"	\n"
"	btAabbCL rigidAabb = rigidBodyWorldAabbs[i];\n"
"	//rigidAabb.m_min.w = 0.0f;	//	check if necessary(if using vector functions for point-AABB test)\n"
"	//rigidAabb.m_max.w = 0.0f;\n"
"	\n"
"	b3Vector3 expandedRigidAabbMin = rigidAabb.m_min - radiusAabbExtent;\n"
"	b3Vector3 expandedRigidAabbMax = rigidAabb.m_max + radiusAabbExtent;\n"
"	\n"
"	b3Scalar maxAabbExtent = gridCellSize * (b3Scalar)B3_FLUID_GRID_COORD_RANGE_HALVED;\n"
"	if( fabs(expandedRigidAabbMin.x) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMin.y) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMin.z) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.x) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.y) > maxAabbExtent\n"
"	 || fabs(expandedRigidAabbMax.z) > maxAabbExtent ) return;\n"
"	\n"
"	\n"
"	b3FluidGridPosition quantizedAabbMin = getDiscretePosition( gridCellSize, expandedRigidAabbMin );\n"
"	b3FluidGridPosition quantizedAabbMax = getDiscretePosition( gridCellSize, expandedRigidAabbMax );\n"
"	\n"
"	for(int z = quantizedAabbMin.z; z <= quantizedAabbMax.z; ++z)\n"
"		for(int y = quantizedAabbMin.y; y <= quantizedAabbMax.y; ++y)\n"
"			for(int x = quantizedAabbMin.x; x <= quantizedAabbMax.x; ++x)\n"
"			{\n"
"				b3FluidGridPosition currentCell;\n"
"				currentCell.x = x;\n"
"				currentCell.y = y;\n"
"				currentCell.z = z;\n"
"				\n"
"				b3FluidGridCombinedPos currentCellValue = getCombinedPosition(currentCell);\n"
"			\n"
"				int cellIndex = binarySearch(cellValues, numGridCells, currentCellValue);\n"
"				if(cellIndex != numGridCells)\n"
"				{\n"
"					b3FluidGridIterator fluidCell = cellContents[cellIndex]; \n"
"					for(int particleIndex = fluidCell.m_firstIndex; particleIndex <= fluidCell.m_lastIndex; ++particleIndex)\n"
"					{\n"
"						b3Vector3 particlePos = fluidPosition[particleIndex];\n"
"						//particlePos.w = 0.0f;	//	check if necessary(if using vector functions for point-AABB test)\n"
"						\n"
"						if( expandedRigidAabbMin.x <= particlePos.x && particlePos.x <= expandedRigidAabbMax.x\n"
"						 && expandedRigidAabbMin.y <= particlePos.y && particlePos.y <= expandedRigidAabbMax.y\n"
"						 && expandedRigidAabbMin.z <= particlePos.z && particlePos.z <= expandedRigidAabbMax.z )\n"
"						{\n"
"							int pairIndex = atomic_inc(&out_pairs[particleIndex].m_numIndicies);\n"
"							if(pairIndex < MAX_FLUID_RIGID_PAIRS) out_pairs[particleIndex].m_rigidIndicies[pairIndex] = i;\n"
"						}\n"
"					}\n"
"				}\n"
"				\n"
"			}\n"
"	\n"
"}\n"
"\n"
"__kernel void fluidRigidNarrowphase(__constant b3FluidSphParametersGlobal* FG, __constant b3FluidSphParametersLocal* FL, \n"
"									__global b3Vector3* fluidPosition, __global FluidRigidPairs* pairs, \n"
"									__global BodyData* rigidBodies, __global btCollidableGpu* collidables,\n"
"									__global ConvexPolyhedronCL* convexShapes, __global btGpuFace* faces,\n"
"									__global int* convexIndices, __global float4* convexVertices, \n"
"									__global FluidRigidContacts* out_contact,\n"
"									int numFluidParticles)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numFluidParticles) return;\n"
"	\n"
"	FluidRigidPairs currentPairs = pairs[i];\n"
"	for(int numRigids = 0; numRigids < currentPairs.m_numIndicies; ++numRigids)\n"
"	{\n"
"		int rigidIndex = currentPairs.m_rigidIndicies[numRigids];\n"
"	\n"
"		BodyData rigidBody = rigidBodies[rigidIndex];\n"
"		\n"
"		int collidableIndex = rigidBody.m_collidableIdx;\n"
"		\n"
"		bool isColliding = false;\n"
"		float distance;\n"
"		float4 normalOnRigid;\n"
"		float4 pointOnRigid;\n"
"		\n"
"		switch(collidables[collidableIndex].m_shapeType)\n"
"		{\n"
"			case SHAPE_CONVEX_HULL:\n"
"			{\n"
"				isColliding = computeContactSphereConvex( collidableIndex, collidables, convexShapes, convexVertices, convexIndices, faces,\n"
"														fluidPosition[i], FL->m_particleRadius, rigidBody.m_pos, rigidBody.m_quat,\n"
"														&distance, &normalOnRigid, &pointOnRigid );\n"
"				normalOnRigid = -normalOnRigid;		//	computeContactSphereConvex() actually returns normal on particle?\n"
"			}\n"
"				break;\n"
"				\n"
"			case SHAPE_PLANE:\n"
"			{\n"
"				float4 rigidPlaneEquation = faces[ collidables[collidableIndex].m_shapeIndex ].m_plane;\n"
"		\n"
"				isColliding = computeContactSpherePlane(fluidPosition[i], FL->m_particleRadius, \n"
"														rigidBody.m_pos, rigidBody.m_quat, rigidPlaneEquation,\n"
"														&distance, &normalOnRigid, &pointOnRigid );\n"
"			}\n"
"				break;\n"
"			\n"
"			case SHAPE_SPHERE:\n"
"			{\n"
"				float rigidSphereRadius = collidables[collidableIndex].m_radius;\n"
"			\n"
"				isColliding = computeContactSphereSphere(fluidPosition[i], FL->m_particleRadius,\n"
"														rigidBody.m_pos, rigidSphereRadius,\n"
"														&distance, &normalOnRigid, &pointOnRigid);\n"
"			}\n"
"				break;\n"
"			\n"
"			default:\n"
"				continue;\n"
"		}\n"
"		\n"
"		\n"
"		if(isColliding)\n"
"		{\n"
"			int contactIndex = out_contact[i].m_numContacts;\n"
"			\n"
"			out_contact[i].m_rigidIndicies[contactIndex] = rigidIndex;\n"
"			out_contact[i].m_distances[contactIndex] = distance;\n"
"			out_contact[i].m_pointsOnRigid[contactIndex] = pointOnRigid;\n"
"			out_contact[i].m_normalsOnRigid[contactIndex] = normalOnRigid;		\n"
"			\n"
"			++out_contact[i].m_numContacts;\n"
"		}\n"
"		\n"
"		if(out_contact[i].m_numContacts >= MAX_RIGID_CONTACTS_PER_FLUID_PARTICLE) return;\n"
"	}\n"
"}\n"
"\n"
"__kernel void resolveFluidRigidCollisions(__constant b3FluidSphParametersGlobal* FG, __constant b3FluidSphParametersLocal* FL, \n"
"											__global BodyData* rigidBodies, __global InertiaTensor* rigidInertias,\n"
"											__global FluidRigidContacts* contacts, \n"
"											__global b3Vector3* fluidVel, __global b3Vector3* fluidVelEval, int numFluidParticles)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if(i >= numFluidParticles) return;\n"
"\n"
"	for(int contactIndex = 0; contactIndex < contacts[i].m_numContacts; ++contactIndex)\n"
"	{\n"
"		b3Vector3 fluidVelocity = fluidVel[i];\n"
"		FluidRigidContacts contact = contacts[i];\n"
"	\n"
"		int rigidIndex = contact.m_rigidIndicies[contactIndex];\n"
"		b3Scalar distance = contact.m_distances[contactIndex];\n"
"		b3Vector3 normalOnRigid = contact.m_normalsOnRigid[contactIndex];\n"
"		b3Vector3 pointOnRigid = contact.m_pointsOnRigid[contactIndex];\n"
"		\n"
"		b3Vector3 rigidPosition = rigidBodies[rigidIndex].m_pos;\n"
"		b3Vector3 rigidLinearVelocity = rigidBodies[rigidIndex].m_linVel;\n"
"		b3Vector3 rigidAngularVelocity = rigidBodies[rigidIndex].m_angVel;\n"
"		b3Scalar rigidInvMass = rigidBodies[rigidIndex].m_invMass;\n"
"		Matrix3x3 rigidInertiaTensor = rigidInertias[rigidIndex].m_invInertia;\n"
"		\n"
"		if( distance < 0.0f )\n"
"		{\n"
"			bool isDynamicRigidBody = (rigidInvMass != 0.0f);\n"
"			\n"
"			b3Vector3 rigidLocalHitPoint = pointOnRigid - rigidPosition;\n"
"			\n"
"			b3Vector3 rigidVelocity = (b3Vector3){0.0f, 0.0f, 0.0f, 0.0f};\n"
"			if(isDynamicRigidBody) rigidVelocity = rigidLinearVelocity + cross3(rigidAngularVelocity, rigidLocalHitPoint);\n"
"			rigidVelocity *= FG->m_simulationScale;\n"
"		\n"
"			b3Vector3 relativeVelocity = fluidVelocity - rigidVelocity;\n"
"			b3Scalar penetratingMagnitude = b3Vector3_dot(relativeVelocity, -normalOnRigid);\n"
"			if( penetratingMagnitude < 0.0f ) penetratingMagnitude = 0.0f;\n"
"			\n"
"			b3Vector3 penetratingVelocity = -normalOnRigid * penetratingMagnitude;\n"
"			b3Vector3 tangentialVelocity = relativeVelocity - penetratingVelocity;\n"
"			\n"
"			penetratingVelocity *= 1.0f + FL->m_boundaryRestitution;\n"
"			\n"
"			b3Scalar penetration = -distance;\n"
"			penetration = (penetration > FL->m_particleMargin) ? penetration : 0.0f;\n"
"			b3Scalar positionError = penetration * (FG->m_simulationScale/FG->m_timeStep) * FL->m_boundaryErp;\n"
"			\n"
"			b3Vector3 particleImpulse = -(penetratingVelocity + (-normalOnRigid*positionError) + tangentialVelocity*FL->m_boundaryFriction);\n"
"			\n"
"			if(isDynamicRigidBody)\n"
"			{\n"
"				b3Scalar inertiaParticle = 1.0f / FL->m_particleMass;\n"
"				\n"
"				b3Vector3 relPosCrossNormal = cross3(rigidLocalHitPoint, normalOnRigid);\n"
"				b3Scalar inertiaRigid = rigidInvMass + b3Vector3_dot( mtMul3(relPosCrossNormal, rigidInertiaTensor), relPosCrossNormal );\n"
"				\n"
"				particleImpulse *= 1.0f / (inertiaParticle + inertiaRigid);\n"
"				\n"
"				//b3Vector3 worldScaleImpulse = -particleImpulse / FG->m_simulationScale;\n"
"				//worldScaleImpulse /= FG->m_timeStep;		//Impulse is accumulated as force\n"
"				\n"
"				//const b3Vector3& linearFactor = rigidBody->getLinearFactor();\n"
"				//accumulatedRigidForce += worldScaleImpulse * linearFactor;\n"
"				//accumulatedRigidTorque += rigidLocalHitPoint.cross(worldScaleImpulse * linearFactor) * rigidBody->getAngularFactor();\n"
"				\n"
"				particleImpulse *= inertiaParticle;\n"
"			}\n"
"			\n"
"			//Leapfrog integration\n"
"			b3Vector3 velNext = fluidVelocity + particleImpulse;\n"
"			fluidVelEval[i] = (fluidVelocity + velNext) * 0.5f;\n"
"			fluidVel[i] = velNext;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"\n"
"__kernel void clearRigidFluidContacts(__global RigidFluidContacts* out_rigidFluidContacts, int numRigidBodies)\n"
"{\n"
"	int rigidIndex = get_global_id(0);\n"
"	if(rigidIndex >= numRigidBodies) return;\n"
"	\n"
"	out_rigidFluidContacts[rigidIndex].m_numContacts = 0;\n"
"}\n"
"\n"
"__kernel void mapRigidFluidContacts(__global FluidRigidContacts* fluidRigidContacts,\n"
"									__global RigidFluidContacts* out_rigidFluidContacts, int numFluidParticles)\n"
"{\n"
"	int particleIndex = get_global_id(0);\n"
"	if(particleIndex >= numFluidParticles) return;\n"
"	\n"
"	FluidRigidContacts contacts = fluidRigidContacts[particleIndex];\n"
"	for(int n = 0; n < contacts.m_numContacts; ++n)\n"
"	{\n"
"		int rigidIndex = contacts.m_rigidIndicies[n];\n"
"		\n"
"		int pairIndex = atomic_inc(&out_rigidFluidContacts[rigidIndex].m_numContacts);\n"
"		if(pairIndex < MAX_FLUID_CONTACTS_PER_DYNAMIC_RIGID) \n"
"		{\n"
"			out_rigidFluidContacts[rigidIndex].m_fluidIndicies[pairIndex] = particleIndex;\n"
"			out_rigidFluidContacts[rigidIndex].m_contactIndicies[pairIndex] = n;\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"__kernel void resolveRigidFluidCollisions(__constant b3FluidSphParametersGlobal* FG, __constant b3FluidSphParametersLocal* FL, \n"
"											__global BodyData* rigidBodies, __global InertiaTensor* rigidInertias,\n"
"											__global FluidRigidContacts* fluidContacts, __global RigidFluidContacts* rigidContacts, \n"
"											__global b3Vector3* fluidVel, int numRigidBodies)\n"
"{\n"
"	int rigidIndex = get_global_id(0);\n"
"	if(rigidIndex >= numRigidBodies) return;\n"
"	\n"
"	b3Vector3 rigidPosition = rigidBodies[rigidIndex].m_pos;\n"
"	b3Vector3 rigidLinearVelocity = rigidBodies[rigidIndex].m_linVel;\n"
"	b3Vector3 rigidAngularVelocity = rigidBodies[rigidIndex].m_angVel;\n"
"	b3Scalar rigidInvMass = rigidBodies[rigidIndex].m_invMass;\n"
"	Matrix3x3 rigidInertiaTensor = rigidInertias[rigidIndex].m_invInertia;\n"
"	\n"
"	if(rigidInvMass == 0.0f) return;\n"
"	\n"
"	b3Vector3 accumulatedForce = (b3Vector3){0.0f, 0.0f, 0.0f, 0.0f};\n"
"	b3Vector3 accumulatedTorque = (b3Vector3){0.0f, 0.0f, 0.0f, 0.0f};\n"
"	\n"
"	for(int i = 0; i < rigidContacts[rigidIndex].m_numContacts; ++i)\n"
"	{\n"
"		int particleIndex = rigidContacts[rigidIndex].m_fluidIndicies[i];\n"
"		int contactIndex = rigidContacts[rigidIndex].m_contactIndicies[i];\n"
"		\n"
"		b3Vector3 fluidVelocity = fluidVel[particleIndex];\n"
"		\n"
"		b3Scalar distance = fluidContacts[particleIndex].m_distances[contactIndex];\n"
"		b3Vector3 pointOnRigid = fluidContacts[particleIndex].m_pointsOnRigid[contactIndex];\n"
"		b3Vector3 normalOnRigid = fluidContacts[particleIndex].m_normalsOnRigid[contactIndex];\n"
"		\n"
"		if( distance < 0.0f )\n"
"		{\n"
"			bool isDynamicRigidBody = (rigidInvMass != 0.0f);\n"
"			\n"
"			b3Vector3 rigidLocalHitPoint = pointOnRigid - rigidPosition;\n"
"			\n"
"			b3Vector3 rigidVelocity = (b3Vector3){0.0f, 0.0f, 0.0f, 0.0f};\n"
"			if(isDynamicRigidBody) rigidVelocity = rigidLinearVelocity + cross3(rigidAngularVelocity, rigidLocalHitPoint);\n"
"			rigidVelocity *= FG->m_simulationScale;\n"
"		\n"
"			b3Vector3 relativeVelocity = fluidVelocity - rigidVelocity;\n"
"			b3Scalar penetratingMagnitude = b3Vector3_dot(relativeVelocity, -normalOnRigid);\n"
"			if( penetratingMagnitude < 0.0f ) penetratingMagnitude = 0.0f;\n"
"			\n"
"			b3Vector3 penetratingVelocity = -normalOnRigid * penetratingMagnitude;\n"
"			b3Vector3 tangentialVelocity = relativeVelocity - penetratingVelocity;\n"
"			\n"
"			penetratingVelocity *= 1.0f + FL->m_boundaryRestitution;\n"
"			\n"
"			b3Scalar penetration = -distance;\n"
"			penetration = (penetration > FL->m_particleMargin) ? penetration : 0.0f;\n"
"			b3Scalar positionError = penetration * (FG->m_simulationScale/FG->m_timeStep) * FL->m_boundaryErp;\n"
"			\n"
"			b3Vector3 particleImpulse = -(penetratingVelocity + (-normalOnRigid*positionError) + tangentialVelocity*FL->m_boundaryFriction);\n"
"			\n"
"			if(isDynamicRigidBody)\n"
"			{\n"
"				b3Scalar inertiaParticle = 1.0f / FL->m_particleMass;\n"
"				\n"
"				b3Vector3 relPosCrossNormal = cross3(rigidLocalHitPoint, normalOnRigid);\n"
"				b3Scalar inertiaRigid = rigidInvMass + b3Vector3_dot( mtMul3(relPosCrossNormal, rigidInertiaTensor), relPosCrossNormal );\n"
"				\n"
"				particleImpulse *= 1.0f / (inertiaParticle + inertiaRigid);\n"
"				\n"
"				b3Vector3 worldScaleImpulse = -particleImpulse / FG->m_simulationScale;\n"
"				worldScaleImpulse /= FG->m_timeStep;		//Impulse is accumulated as force\n"
"				\n"
"				accumulatedForce += worldScaleImpulse;\n"
"				accumulatedTorque += cross3(rigidLocalHitPoint, worldScaleImpulse);\n"
"				\n"
"				//particleImpulse *= inertiaParticle;\n"
"			}\n"
"		}	\n"
"	}\n"
"	\n"
"	//Apply accumulated forces\n"
"	b3Scalar timeStep = FG->m_timeStep;\n"
"		\n"
"	rigidLinearVelocity += accumulatedForce * (rigidInvMass * timeStep);\n"
"	rigidAngularVelocity += mtMul1(rigidInertiaTensor, accumulatedTorque) * timeStep;\n"
"	\n"
"	//Limit angular velocity\n"
"	float BT_GPU_ANGULAR_MOTION_THRESHOLD = (0.25f * 3.14159254f);\n"
"	b3Scalar angVel = sqrt( b3Vector3_dot(rigidAngularVelocity, rigidAngularVelocity) );\n"
"	if(angVel*timeStep > BT_GPU_ANGULAR_MOTION_THRESHOLD) rigidAngularVelocity *= (BT_GPU_ANGULAR_MOTION_THRESHOLD/timeStep) / angVel;\n"
"	\n"
"	rigidBodies[rigidIndex].m_linVel = rigidLinearVelocity;\n"
"	rigidBodies[rigidIndex].m_angVel = rigidAngularVelocity;\n"
"}\n"
"\n"
;
